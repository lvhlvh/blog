<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LeetCode 题解 Cheatsheet</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Basic body styling */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Light gray background */
        }

        /* Styling for code blocks */
        pre[class*="language-"] {
            max-height: 300px; /* Limit height */
            overflow: auto; /* Enable scrolling */
            border-radius: 0.375rem; /* Rounded corners */
            scrollbar-width: thin; /* Thin scrollbar for Firefox */
            scrollbar-color: #6b7280 #e5e7eb; /* Scrollbar colors for Firefox */
            margin-top: 0.5rem;
            position: relative; /* Needed for copy button positioning */
            padding-top: 2.5rem; /* Space for the copy button */
        }

        /* Webkit scrollbar styling */
        pre[class*="language-"]::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        pre[class*="language-"]::-webkit-scrollbar-track {
            background: #e5e7eb;
            border-radius: 0.375rem;
        }

        pre[class*="language-"]::-webkit-scrollbar-thumb {
            background-color: #6b7280;
            border-radius: 0.375rem;
            border: 2px solid #e5e7eb;
        }

        /* Table layout */
        table {
            table-layout: fixed;
            width: 100%;
        }

        /* Styling for inline code in solution summary */
        .solution-summary-col code {
            background-color: #fce7f3; /* Lighter pink */
            padding: 0.1em 0.4em;
            border-radius: 0.25rem;
            font-size: 0.9em;
            font-family: monospace;
            color: #be185d; /* Pink-700 */
        }

        /* Styling for bold text in solution summary */
        .solution-summary-col strong, .solution-summary-col b {
            font-weight: 600; /* Make text bold */
            color: #1f2937; /* Slightly darker text for emphasis */
        }

        /* Styling for collapsible code details */
        details > summary {
            cursor: pointer;
            list-style: none; /* Remove default marker */
            padding: 4px 8px;
            background-color: #f9fafb; /* Very light gray */
            border: 1px solid #e5e7eb; /* Light border */
            border-radius: 0.375rem;
            display: inline-block;
            font-size: 0.8rem;
            color: #374151; /* Dark gray text */
            transition: background-color 0.2s ease;
        }

        details > summary:hover {
            background-color: #f3f4f6; /* Slightly darker on hover */
        }

        details > summary::-webkit-details-marker {
            display: none; /* Hide default marker in Webkit */
        }

        /* Custom marker for details */
        details > summary::before {
            content: '▶ '; /* Right-pointing triangle */
            font-size: 0.7em;
            margin-right: 4px;
        }

        details[open] > summary::before {
            content: '▼ '; /* Down-pointing triangle when open */
        }

        /* Styling for clickable sort header */
        #sortHeader {
            cursor: pointer;
            user-select: none; /* Prevent text selection */
        }

        #sortHeader:hover {
            background-color: #e5e7eb; /* Slightly darker gray on hover */
        }

        #sortIcon {
            display: inline-block;
            width: 1em; /* Ensure space for icon */
            text-align: center;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            th, td {
                padding: 8px 4px; /* Reduce padding on smaller screens */
                font-size: 0.875rem; /* Slightly smaller font */
            }

            pre[class*="language-"] {
                max-height: 200px; /* Smaller max height for code blocks */
            }

            /* Stack controls vertically on small screens */
            .controls {
                grid-template-columns: 1fr;
            }

            /* Ensure tag buttons wrap nicely */
            #tagFilterContainer {
                justify-content: flex-start;
            }
        }

        /* Tag filter button styling */
        .tag-filter-button {
            transition: all 0.2s ease-in-out;
            border: 1px solid transparent; /* Base border */
            cursor: pointer;
        }

        .tag-filter-button.active {
            font-weight: 600;
            /* Active state uses ring for better visibility */
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5); /* Blue ring, adjust color as needed */
        }

        .tag-filter-button:not(.active):hover {
            opacity: 0.85; /* Slightly more noticeable hover */
            border-color: #9ca3af; /* Gray border on hover */
        }

        /* Specific styling for tags (background/text color) */
        .tag-default {
            background-color: #dcfce7; /* Light green */
            color: #166534; /* Dark green */
            border-color: #a7f3d0; /* Slightly darker green border */
        }

        .tag-hot100 {
            background-color: #dbeafe; /* Light blue */
            color: #1e40af; /* Dark blue */
            border-color: #bfdbfe; /* Slightly darker blue border */
        }

        /* Style for active state (override base colors) */
        .tag-filter-button.active.tag-default {
            background-color: #16a34a; /* Darker Green */
            color: white;
            border-color: #16a34a;
            box-shadow: 0 0 0 2px rgba(22, 163, 74, 0.5); /* Green ring */
        }

        .tag-filter-button.active.tag-hot100 {
            background-color: #2563eb; /* Darker Blue */
            color: white;
            border-color: #2563eb;
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.5); /* Blue ring */
        }

        /* Copy button styling */
        .copy-button {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background-color: #4b5563; /* Gray-700 */
            color: white;
            border: none;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s ease;
            z-index: 10; /* Ensure button is clickable */
        }

        pre[class*="language-"]:hover .copy-button {
            opacity: 1;
        }

        .copy-button:hover {
            background-color: #374151; /* Gray-800 */
        }

        .copy-button.copied {
            background-color: #10b981; /* Emerald-500 */
        }
    </style>
</head>
<body class="antialiased text-gray-800 p-4 md:p-8">

<div class="container mx-auto bg-white p-6 rounded-lg shadow-lg">
    <h1 class="text-2xl md:text-3xl font-bold mb-6 text-center text-gray-700">LeetCode 题解 Cheatsheet</h1>

    <div class="controls mb-6 grid grid-cols-1 md:grid-cols-2 gap-4 items-end">
        <div>
            <label for="searchInput" class="block text-sm font-medium text-gray-600 mb-1">搜索 (题号或标题):</label>
            <input type="text" id="searchInput" placeholder="例如: 1 或 两数之和"
                   class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
        </div>

        <div class="md:col-span-2">
            <label class="block text-sm font-medium text-gray-600 mb-2">按标签筛选 (可多选):</label>
            <div id="tagFilterContainer" class="flex flex-wrap gap-2">
                <button id="clearTagFilter"
                        class="px-3 py-1 bg-gray-500 text-white text-xs font-medium rounded-full hover:bg-gray-600 transition duration-150 ease-in-out hidden">
                    清除所有筛选
                </button>
            </div>
        </div>
    </div>

    <div class="overflow-x-auto">
        <table id="problemsTable" class="min-w-full divide-y divide-gray-200 border border-gray-200 rounded-lg">
            <thead class="bg-gray-50">
            <tr>
                <th scope="col" id="sortHeader"
                    class="w-1/12 px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider transition-colors duration-150 ease-in-out">
                    题号 <span id="sortIcon" class="text-gray-400"></span>
                </th>
                <th scope="col"
                    class="w-2/12 px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">标题
                </th>
                <th scope="col"
                    class="w-2/12 px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">标签
                </th>
                <th scope="col"
                    class="w-3/12 px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider solution-summary-col">
                    解题思路
                </th>
                <th scope="col"
                    class="w-4/12 px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider code-col">
                    Java 代码
                </th>
            </tr>
            </thead>
            <tbody class="bg-white divide-y divide-gray-200">
            <tr id="noResultsRow" class="hidden">
                <td colspan="5" class="text-center py-4 text-gray-500">未找到匹配的题目。</td>
            </tr>
            </tbody>
        </table>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>

<script>
    // --- Data ---
    const hot100Titles = new Set([
        "两数之和", "字母异位词分组", "最长连续序列", "移动零", "盛最多水的容器",
        "三数之和", "接雨水", "无重复字符的最长子串", "找到字符串中所有字母异位词",
        "和为 K 的子数组", "滑动窗口最大值", "最小覆盖子串", "最大子数组和",
        "合并区间", "轮转数组", "除自身以外数组的乘积", "缺失的第一个正数",
        "矩阵置零", "螺旋矩阵", "旋转图像", "搜索二维矩阵 II", "相交链表",
        "反转链表", "回文链表", "环形链表", "环形链表 II", "合并两个有序链表",
        "两数相加", "删除链表的倒数第 N 个结点", "两两交换链表中的节点",
        "K 个一组翻转链表", "随机链表的复制", "排序链表", "合并 K 个升序链表",
        "LRU 缓存", "二叉树的中序遍历", "二叉树的最大深度", "翻转二叉树",
        "对称二叉树", "二叉树的直径", "二叉树的层序遍历", "将有序数组转换为二叉搜索树",
        "验证二叉搜索树", "二叉搜索树中第 K 小的元素", "二叉树的右视图",
        "二叉树展开为链表", "从前序与中序遍历序列构造二叉树", "路径总和 III",
        "二叉树的最近公共祖先", "二叉树中的最大路径和", "岛屿数量", "腐烂的橘子",
        "课程表", "实现 Trie (前缀树)", "全排列", "子集", "电话号码的字母组合",
        "组合总和", "括号生成", "单词搜索", "分割回文串", "N 皇后",
        "搜索插入位置", "搜索二维矩阵", "在排序数组中查找元素的第一个和最后一个位置",
        "搜索旋转排序数组", "寻找旋转排序数组中的最小值", "寻找两个正序数组的中位数",
        "有效的括号", "最小栈", "字符串解码", "每日温度", "柱状图中最大的矩形",
        "数组中的第K个最大元素", "前 K 个高频元素", "数据流的中位数",
        "买卖股票的最佳时机", "跳跃游戏", "跳跃游戏 II", "划分字母区间",
        "爬楼梯", "杨辉三角", "打家劫舍", "完全平方数", "零钱兑换", "单词拆分",
        "最长递增子序列", "乘积最大子数组", "分割等和子集", "最长有效括号",
        "不同路径", "最小路径和", "最长回文子串", "最长公共子序列", "编辑距离",
        "只出现一次的数字", "多数元素", "颜色分类", "下一个排列", "寻找重复数"
    ]);

    const problemsData = [
        {
            id: 1,
            title: "两数之和",
            url: "https://leetcode.cn/problems/two-sum/",
            tags: ["数组", "哈希表"],
            summary: "利用哈希表 (<code>HashMap</code>) 优化查找。遍历数组 <code>nums</code>，对每个元素 <code>nums[i]</code>，计算目标差值 <code>complement = target - nums[i]</code>。检查 <code>complement</code> 是否已存在于哈希表中。若存在，则返回 <code>complement</code> 的索引和当前索引 <code>i</code>。若不存在，将当前元素 <code>nums[i]</code> 及其索引 <code>i</code> 存入哈希表。时间复杂度 O(n)。",
            code: `import java.util.HashMap;
import java.util.Map;

class Solution {
    /**
     * Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
     * You may assume that each input would have exactly one solution, and you may not use the same element twice.
     * You can return the answer in any order.
     *
     * @param nums Integer array
     * @param target Target sum
     * @return Array containing the indices of the two numbers
     */
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            // Check if the complement exists in the map
            if (map.containsKey(complement)) {
                // If found, return the indices
                return new int[] { map.get(complement), i };
            }
            // Put the current number and its index into the map
            map.put(nums[i], i);
        }
        // According to the problem statement, a solution always exists, so this should not be reached.
        throw new IllegalArgumentException("No two sum solution");
    }
}`
        },
        {
            id: 2,
            title: "两数相加",
            url: "https://leetcode.cn/problems/add-two-numbers/",
            tags: ["递归", "链表", "数学"],
            summary: "模拟手动加法过程。使用哑节点 <code>dummyHead</code> 简化头节点处理。同时遍历链表 <code>l1</code> 和 <code>l2</code>，逐位相加，记录进位 <code>carry</code>。将每位的和 (<code>sum % 10</code>) 创建为新节点，连接到结果链表。若最后仍有进位，需添加额外节点。返回 <code>dummyHead.next</code>。",
            code: `/**
 * Definition for singly-linked list.
 * Assume ListNode class is defined elsewhere or provided by LeetCode environment.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    /**
     * You are given two non-empty linked lists representing two non-negative integers.
     * The digits are stored in reverse order, and each of their nodes contains a single digit.
     * Add the two numbers and return the sum as a linked list.
     *
     * @param l1 The first linked list
     * @param l2 The second linked list
     * @return The head of the linked list representing the sum
     */
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode(0); // Dummy node to simplify head handling
        ListNode current = dummyHead;
        int carry = 0; // Carry-over
        // Iterate through both lists until both are null AND carry is 0
        while (l1 != null || l2 != null || carry != 0) { // Added carry check
            int x = (l1 != null) ? l1.val : 0;
            int y = (l2 != null) ? l2.val : 0;
            int sum = carry + x + y;
            carry = sum / 10; // Calculate new carry

            // Create a new node for the current digit sum (modulo 10)
            current.next = new ListNode(sum % 10);
            current = current.next;

            // Move to the next nodes
            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }
        // The final carry check is now part of the while loop condition
        // Return the next node of the dummy head, which is the actual head of the result list
        return dummyHead.next;
    }
}`
        },
        {
            id: 3,
            title: "无重复字符的最长子串",
            url: "https://leetcode.cn/problems/longest-substring-without-repeating-characters/",
            tags: ["哈希表", "字符串", "滑动窗口"],
            summary: "使用滑动窗口和哈希表 (<code>HashMap<Character, Integer></code>) 记录字符最新索引。维护左右指针 <code>left</code> 和 <code>right</code>。移动 <code>right</code> 扩展窗口，将字符和索引存入哈希表。若遇到重复字符 <code>s.charAt(right)</code> 且其索引 <code>map.get(currentChar) >= left</code>，则将 <code>left</code> 移动到重复字符的下一个位置。每次移动 <code>right</code> 后，更新最大长度 <code>maxLength = Math.max(maxLength, right - left + 1)</code>。返回 <code>maxLength</code>。",
            code: `import java.util.HashMap;
import java.util.Map;

class Solution {
    /**
     * Given a string s, find the length of the longest substring without repeating characters.
     *
     * @param s Input string
     * @return Length of the longest substring without repeating characters
     */
    public int lengthOfLongestSubstring(String s) {
        int n = s.length();
        if (n == 0) {
            return 0;
        }
        // Use HashMap to store characters and their latest indices
        Map<Character, Integer> map = new HashMap<>();
        int maxLength = 0;
        int left = 0; // Left boundary of the sliding window

        for (int right = 0; right < n; right++) {
            char currentChar = s.charAt(right);
            // If the current character is already in the window (i.e., in the map and its index >= left)
            if (map.containsKey(currentChar) && map.get(currentChar) >= left) {
                // Move the left boundary to the position after the repeated character
                left = map.get(currentChar) + 1;
            }
            // Update the latest index of the current character
            map.put(currentChar, right);
            // Calculate the current window length and update the maximum length
            maxLength = Math.max(maxLength, right - left + 1);
        }
        return maxLength;
    }
}`
        },
        {
            id: 4,
            title: "寻找两个正序数组的中位数",
            url: "https://leetcode.cn/problems/median-of-two-sorted-arrays/",
            tags: ["数组", "二分查找", "分治"],
            summary: "要求 O(log(min(m,n))) 复杂度。核心是在较短数组（设为 <code>nums1</code>）上进行二分查找，寻找分割点 <code>i</code>，对应 <code>nums2</code> 的分割点为 <code>j = (m+n+1)/2 - i</code>。目标是找到满足 <code>nums1[i-1] <= nums2[j]</code> 且 <code>nums2[j-1] <= nums1[i]</code> 的 <code>i</code>。根据 <code>nums1[i-1]</code> 和 <code>nums2[j]</code> 的大小关系调整二分查找范围。找到合适的 <code>i</code> 后，根据总长度奇偶性计算中位数：奇数时为 <code>max(nums1[i-1], nums2[j-1])</code>，偶数时为 <code>(max(nums1[i-1], nums2[j-1]) + min(nums1[i], nums2[j])) / 2.0</code>。注意处理边界情况（分割点在数组端点）。",
            code: `class Solution {
    /**
     * Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.
     * The overall run time complexity should be O(log (m+n)).
     *
     * @param nums1 The first sorted array
     * @param nums2 The second sorted array
     * @return The median of the two sorted arrays
     */
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int m = nums1.length;
        int n = nums2.length;
        // Ensure nums1 is the shorter array to optimize binary search
        if (m > n) {
            return findMedianSortedArrays(nums2, nums1); // Swap arrays
        }

        int totalLeft = (m + n + 1) / 2; // Total number of elements desired in the combined left half
        int low = 0; // Binary search range for partition index i in nums1
        int high = m;

        while (low <= high) { // Use standard binary search condition
            int i = low + (high - low) / 2; // Partition index for nums1
            int j = totalLeft - i;      // Corresponding partition index for nums2

            // Get the four boundary elements, handle edge cases with MIN/MAX_VALUE
            int nums1LeftMax = (i == 0) ? Integer.MIN_VALUE : nums1[i - 1];
            int nums1RightMin = (i == m) ? Integer.MAX_VALUE : nums1[i];
            int nums2LeftMax = (j == 0) ? Integer.MIN_VALUE : nums2[j - 1];
            int nums2RightMin = (j == n) ? Integer.MAX_VALUE : nums2[j];

            // Check if the partition is correct
            if (nums1LeftMax <= nums2RightMin && nums2LeftMax <= nums1RightMin) {
                // Partition is correct, calculate median
                if ((m + n) % 2 == 1) { // Odd total length
                    return Math.max(nums1LeftMax, nums2LeftMax);
                } else { // Even total length
                    return (double) (Math.max(nums1LeftMax, nums2LeftMax) + Math.min(nums1RightMin, nums2RightMin)) / 2.0;
                }
            } else if (nums1LeftMax > nums2RightMin) {
                // Partition i in nums1 is too large, decrease high
                high = i - 1;
            } else { // nums2LeftMax > nums1RightMin
                // Partition i in nums1 is too small, increase low
                low = i + 1;
            }
        }
        // Should not be reached if input arrays are sorted
        throw new IllegalArgumentException("Input arrays are not sorted or invalid.");
    }
}`
        },
        {
            id: 5,
            title: "最长回文子串",
            url: "https://leetcode.cn/problems/longest-palindromic-substring/",
            tags: ["字符串", "动态规划"],
            summary: "方法：<strong>中心扩展法</strong>。遍历字符串 <code>s</code>，以每个索引 <code>i</code> 以及 <code>i</code> 和 <code>i+1</code> 之间作为中心点。调用 <code>expandAroundCenter(s, left, right)</code> 函数从中心向两边扩展，查找并返回以该中心为基准的最长回文串长度 <code>len</code>。记录并更新全局最长回文串的起止索引 <code>start</code> 和 <code>end</code>。最后返回 <code>s.substring(start, end + 1)</code>。<br><code>expandAroundCenter</code> 函数: 从给定的 <code>left</code>, <code>right</code> 中心向两边扩展，直到边界或字符不匹配，返回找到的回文串长度。",
            code: `class Solution {
    /**
     * Given a string s, return the longest palindromic substring in s.
     * A string is called a palindrome string if the reverse of that string is the same as the original string.
     *
     * @param s Input string
     * @return The longest palindromic substring
     */
    public String longestPalindrome(String s) {
        if (s == null || s.length() < 1) {
            return "";
        }
        int start = 0; // Start index of the longest palindrome found so far
        int end = 0;   // End index of the longest palindrome found so far

        for (int i = 0; i < s.length(); i++) {
            // Handle odd length palindromes (center is a single character i)
            int len1 = expandAroundCenter(s, i, i);
            // Handle even length palindromes (center is between characters i and i+1)
            int len2 = expandAroundCenter(s, i, i + 1);
            int len = Math.max(len1, len2);

            // If a longer palindrome is found, update start and end indices
            // Current palindrome length is end - start + 1
            if (len > end - start + 1) {
                // Calculate new start and end based on center i and length len
                start = i - (len - 1) / 2;
                end = i + len / 2;
            }
        }
        // Extract the substring based on start and end indices (inclusive)
        return s.substring(start, end + 1);
    }

    /**
     * Helper function to expand around the center and find the length of the longest palindrome.
     *
     * @param s     Input string
     * @param left  Left boundary (or center point)
     * @param right Right boundary (or center point)
     * @return The length of the longest palindrome centered at left and right
     */
    private int expandAroundCenter(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;  // Expand left
            right++; // Expand right
        }
        // The length of the palindrome is R - L - 1 after the loop terminates
        // Example "aba": L=-1, R=3 -> R-L-1 = 3 - (-1) - 1 = 3
        // Example "abba": L=-1, R=4 -> R-L-1 = 4 - (-1) - 1 = 4
        return right - left - 1;
    }
}`
        },
        {
            id: 7,
            title: "整数反转",
            url: "https://leetcode.cn/problems/reverse-integer/",
            tags: ["数学"],
            summary: "循环处理整数 <code>x</code> 直到其为 0。每次取末位 <code>digit = x % 10</code>，移除末位 <code>x /= 10</code>。在更新反转结果 <code>reversed = reversed * 10 + digit</code> <strong>之前</strong>，必须进行<strong>溢出检查</strong>：检查 <code>reversed</code> 是否大于 <code>Integer.MAX_VALUE / 10</code> 或小于 <code>Integer.MIN_VALUE / 10</code>，以及在等于边界值时 <code>digit</code> 是否会导致溢出。若溢出，返回 0。否则，更新 <code>reversed</code>。循环结束后返回 <code>reversed</code>。",
            code: `class Solution {
    /**
     * Given a signed 32-bit integer x, return x with its digits reversed.
     * If reversing x causes the value to go outside the signed 32-bit integer range [-2^31, 2^31 - 1], then return 0.
     * Assume the environment does not allow you to store 64-bit integers (signed or unsigned).
     *
     * @param x Input integer
     * @return Reversed integer, or 0 if overflow occurs
     */
    public int reverse(int x) {
        int reversed = 0;
        while (x != 0) {
            int digit = x % 10; // Get the last digit
            x /= 10;         // Remove the last digit

            // Check for positive overflow BEFORE multiplication/addition
            if (reversed > Integer.MAX_VALUE / 10 || (reversed == Integer.MAX_VALUE / 10 && digit > 7)) {
                return 0;
            }
            // Check for negative overflow BEFORE multiplication/addition
            if (reversed < Integer.MIN_VALUE / 10 || (reversed == Integer.MIN_VALUE / 10 && digit < -8)) {
                return 0;
            }

            reversed = reversed * 10 + digit; // Append the digit
        }
        return reversed;
    }
}`
        },
        {
            id: 8,
            title: "字符串转换整数 (atoi)",
            url: "https://leetcode.cn/problems/string-to-integer-atoi/",
            tags: ["字符串"],
            summary: "按规则模拟转换：跳过前导空格；检查可选的 '+' 或 '-' 号，记录符号 <code>sign</code>；循环读取数字字符，累加到 <code>result</code> (使用 <code>long</code> 类型)。在累加<strong>之前</strong>检查是否会超出 <code>Integer</code> 范围，若超出则提前返回边界值；遇到非数字字符或结束时停止；返回 <code>(int)(result * sign)</code>，并做最终范围检查。",
            code: `class Solution {
    /**
     * Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).
     *
     * @param s Input string
     * @return The converted integer
     */
    public int myAtoi(String s) {
        int index = 0;
        int n = s.length();

        // 1. Discard leading whitespace
        while (index < n && s.charAt(index) == ' ') {
            index++;
        }

        // 2. Check for optional sign
        int sign = 1;
        if (index < n && (s.charAt(index) == '+' || s.charAt(index) == '-')) {
            sign = (s.charAt(index) == '-') ? -1 : 1;
            index++;
        }

        long result = 0; // Use long to prevent intermediate overflow

        // 3. Read digits and handle overflow
        while (index < n && Character.isDigit(s.charAt(index))) {
            int digit = s.charAt(index) - '0';

            // Check for overflow BEFORE updating result
            // Check if result * 10 + digit will exceed MAX_VALUE for positive numbers
            if (sign == 1 && result > (Integer.MAX_VALUE - digit) / 10) {
                 return Integer.MAX_VALUE;
            }
             // Check if result * 10 + digit will exceed MIN_VALUE for negative numbers
             // Careful with MIN_VALUE which is -2^31
             if (sign == -1 && -result < (Integer.MIN_VALUE + digit) / 10 ) { // Check negative overflow
                 return Integer.MIN_VALUE;
             }


            result = result * 10 + digit;
            index++;
        }

        // 4. Apply sign
        result *= sign;

        // 5. Final clamp to Integer range
        if (result > Integer.MAX_VALUE) {
            return Integer.MAX_VALUE;
        }
        if (result < Integer.MIN_VALUE) {
            return Integer.MIN_VALUE;
        }

        return (int) result;
    }
}`
        },
        {
            id: 9,
            title: "回文数",
            url: "https://leetcode.cn/problems/palindrome-number/",
            tags: ["数学"],
            summary: "判断整数 <code>x</code> 是否回文。方法1：转为字符串判断。方法2：数学方法。排除特殊情况（负数、末尾为0的非零数）。使用 <code>while (x > revertedNumber)</code> 循环反转 <code>x</code> 的后半部分到 <code>revertedNumber</code>。最后比较：若长度为偶数，判断 <code>x == revertedNumber</code>；若长度为奇数，判断 <code>x == revertedNumber / 10</code>。",
            code: `class Solution {
    /**
     * Given an integer x, return true if x is a palindrome integer.
     * An integer is a palindrome when it reads the same backward as forward.
     * For example, 121 is palindrome while 123 is not.
     *
     * @param x Input integer
     * @return True if x is a palindrome, false otherwise
     */
    public boolean isPalindrome(int x) {
        // Special cases:
        // Negative numbers are not palindromes.
        // Also, if the last digit of the number is 0, in order to be a palindrome,
        // the first digit of the number also needs to be 0. Only 0 satisfies this property.
        if (x < 0 || (x % 10 == 0 && x != 0)) {
            return false;
        }

        int revertedNumber = 0;
        // Reverse the second half of the number
        while (x > revertedNumber) {
            revertedNumber = revertedNumber * 10 + x % 10;
            x /= 10;
        }

        // When the length is an odd number, we can get rid of the middle digit by revertedNumber/10
        // For example when the input is 12321, at the end of the while loop we get x = 12, revertedNumber = 123,
        // since the middle digit doesn't matter in palidrome(it will always equal to itself), we can simply get rid of it.
        // When the length is an even number, x == revertedNumber
        // For example when the input is 1221, at the end of the while loop we get x = 12, revertedNumber = 12
        return x == revertedNumber || x == revertedNumber / 10;
    }
}`
        },
        {
            id: 10,
            title: "正则表达式匹配",
            url: "https://leetcode.cn/problems/regular-expression-matching/",
            tags: ["递归", "字符串", "动态规划"],
            summary: "使用<strong>动态规划</strong>。定义 <code>dp[i][j]</code> 为 <code>s</code> 前 <code>i</code> 字符与 <code>p</code> 前 <code>j</code> 字符是否匹配。初始化 <code>dp[0][0]=true</code> 及处理 <code>p</code> 开头的 <code>*</code>。状态转移：若 <code>p[j-1]</code> 匹配 <code>s[i-1]</code> (或为 <code>.</code>)，则 <code>dp[i][j] = dp[i-1][j-1]</code>；若 <code>p[j-1] == '*'</code>，则 <code>dp[i][j]</code> 可由 <code>*</code> 匹配 0 次 (<code>dp[i][j-2]</code>) 或 <code>*</code> 匹配 1 次或多次 (<code>dp[i-1][j]</code> 且 <code>s[i-1]</code> 匹配 <code>p[j-2]</code>) 得到。返回 <code>dp[m][n]</code>。",
            code: `class Solution {
    /**
     * Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'.
     * '.' Matches any single character.
     * '*' Matches zero or more of the preceding element.
     * The matching should cover the entire input string (not partial).
     *
     * @param s Input string
     * @param p Pattern string
     * @return True if s and p match, false otherwise
     */
    public boolean isMatch(String s, String p) {
        int m = s.length();
        int n = p.length();

        // dp[i][j] represents if the first i characters of s match the first j characters of p
        boolean[][] dp = new boolean[m + 1][n + 1];
        dp[0][0] = true; // Empty string matches empty pattern

        // Handle patterns like a*, a*b*, a*b*c* that can match an empty string
        // Initialize dp[0][j] for patterns matching empty string
        for (int j = 1; j <= n; j++) {
            if (p.charAt(j - 1) == '*') {
                // '*' can match zero preceding elements. Check dp[0][j-2].
                 if (j >= 2) { // Ensure there is a preceding character
                    dp[0][j] = dp[0][j - 2];
                 }
                 // else: '*' at the beginning or after another '*' is invalid or handled by dp[0][j-2] being false
            }
        }

        // Fill the DP table
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                char sChar = s.charAt(i - 1);
                char pChar = p.charAt(j - 1);

                if (pChar == '.' || sChar == pChar) {
                    // Case 1: Current characters match or pattern has '.'
                    dp[i][j] = dp[i - 1][j - 1];
                } else if (pChar == '*') {
                    // Case 2: Pattern has '*'
                    // '*' must have a preceding character p[j-2]
                    if (j >= 2) {
                        // Option A: '*' matches zero occurrences of p[j-2]
                        // Check if s[0..i-1] matches p[0..j-3]
                        boolean matchZero = dp[i][j - 2];

                        // Option B: '*' matches one or more occurrences of p[j-2]
                        // This requires p[j-2] to match s[i-1]
                        boolean matchOneOrMore = false;
                        if (p.charAt(j - 2) == '.' || p.charAt(j - 2) == sChar) {
                            // If they match, '*' can potentially match s[i-1].
                            // The result depends on whether s[0..i-2] matches p[0..j-1] (including the '*')
                            // dp[i-1][j] means the '*' is used to match s[i-1]
                            matchOneOrMore = dp[i - 1][j];
                        }
                        dp[i][j] = matchZero || matchOneOrMore;
                    }
                    // else: '*' at beginning or after another '*', dp[i][j] remains false

                }
                // Case 3: Characters mismatch and pattern is not '*', dp[i][j] remains false (default)
            }
        }

        return dp[m][n]; // Return the result for the full strings
    }
}`
        },
        {
            id: 11,
            title: "盛最多水的容器",
            url: "https://leetcode.cn/problems/container-with-most-water/",
            tags: ["贪心", "数组", "双指针"],
            summary: "使用<strong>双指针</strong>和<strong>贪心</strong>策略。初始化左右指针 <code>left</code>, <code>right</code> 指向数组首尾，最大面积 <code>maxArea = 0</code>。当 <code>left < right</code> 时循环：计算当前高度 <code>h = min(height[left], height[right])</code> 和宽度 <code>width = right - left</code>，更新 <code>maxArea</code>。然后，将指向<strong>较短板</strong>的指针向内移动一步。这是因为移动短板才可能遇到更高的板，从而增大面积。",
            code: `class Solution {
    /**
     * Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai).
     * n vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0).
     * Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.
     * Return the maximum amount of water a container can store.
     * Notice that you may not slant the container.
     *
     * @param height Array representing the heights of the vertical lines
     * @return Maximum amount of water that can be stored
     */
    public int maxArea(int[] height) {
        int maxArea = 0;
        int left = 0; // Left pointer
        int right = height.length - 1; // Right pointer

        while (left < right) {
            // Calculate the width of the current container
            int width = right - left;
            // Calculate the height of the current container (limited by the shorter line)
            int h = Math.min(height[left], height[right]);
            // Calculate the area of the current container and update maxArea
            maxArea = Math.max(maxArea, width * h);

            // Move the pointer pointing to the shorter line inward
            // This is the greedy choice: moving the shorter line's pointer
            // gives a chance to find a taller line, potentially increasing the area.
            // Moving the taller line's pointer will definitely not increase the height,
            // and will decrease the width, thus decreasing the area.
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }
        return maxArea;
    }
}`
        },
        {
            id: 12,
            title: "整数转罗马数字",
            url: "https://leetcode.cn/problems/integer-to-roman/",
            tags: ["哈希表", "数学", "字符串"],
            summary: "采用<strong>贪心</strong>策略。预定义罗马数字符号及其对应的值（包括特殊组合如 <code>CM</code>, <code>CD</code>, <code>XC</code>, <code>XL</code>, <code>IX</code>, <code>IV</code>），按值从大到小存储。遍历这个映射关系，对于每个值 <code>value</code> 和符号 <code>symbol</code>，当输入整数 <code>num >= value</code> 时，将 <code>symbol</code> 追加到结果字符串，并将 <code>num</code> 减去 <code>value</code>，重复此过程直到 <code>num < value</code>。继续处理下一个更小的值。",
            code: `import java.util.LinkedHashMap;
import java.util.Map;

class Solution {
    /**
     * Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
     * ... (rules omitted) ...
     * Given an integer, convert it to a roman numeral.
     *
     * @param num Input integer (1 <= num <= 3999)
     * @return The corresponding Roman numeral string
     */
    public String intToRoman(int num) {
        // Use LinkedHashMap to maintain insertion order (from largest to smallest value)
        Map<Integer, String> romanMap = new LinkedHashMap<>();
        romanMap.put(1000, "M");
        romanMap.put(900, "CM");
        romanMap.put(500, "D");
        romanMap.put(400, "CD");
        romanMap.put(100, "C");
        romanMap.put(90, "XC");
        romanMap.put(50, "L");
        romanMap.put(40, "XL");
        romanMap.put(10, "X");
        romanMap.put(9, "IX");
        romanMap.put(5, "V");
        romanMap.put(4, "IV");
        romanMap.put(1, "I");

        StringBuilder roman = new StringBuilder();

        // Greedy algorithm: Iterate through the map from largest value to smallest
        for (Map.Entry<Integer, String> entry : romanMap.entrySet()) {
            int value = entry.getKey();
            String symbol = entry.getValue();

            // Append the symbol as many times as possible
            while (num >= value) {
                roman.append(symbol);
                num -= value;
            }

            if (num == 0) {
                break; // Optimization: if num becomes 0, we are done
            }
        }
        return roman.toString();
    }
}`
        },
        {
            id: 14,
            title: "最长公共前缀",
            url: "https://leetcode.cn/problems/longest-common-prefix/",
            tags: ["字符串"],
            summary: "方法：<strong>纵向扫描</strong>。以第一个字符串 <code>strs[0]</code> 为基准。遍历第一个字符串的每个字符（索引 <code>i</code>）。对于每个字符 <code>c = strs[0].charAt(i)</code>，检查数组中所有其他字符串 <code>strs[j]</code> 的相同位置 <code>i</code> 上的字符。如果遇到任何字符串长度不足 <code>i</code>，或者 <code>strs[j].charAt(i) != c</code>，则说明最长公共前缀是 <code>strs[0]</code> 的前 <code>i</code> 个字符 (<code>strs[0].substring(0, i)</code>)。如果遍历完第一个字符串的所有字符都匹配，则第一个字符串本身就是最长公共前缀。",
            code: `class Solution {
    /**
     * Write a function to find the longest common prefix string amongst an array of strings.
     * If there is no common prefix, return an empty string "".
     *
     * @param strs Array of strings
     * @return The longest common prefix
     */
    public String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0) {
            return "";
        }

        // Use the first string as the reference
        String firstString = strs[0];
        int prefixLength = firstString.length();
        int count = strs.length;

        // Iterate through characters of the first string
        for (int i = 0; i < prefixLength; i++) {
            char c = firstString.charAt(i); // Character to compare

            // Compare this character with the character at the same position in other strings
            for (int j = 1; j < count; j++) {
                // If the other string is shorter than index i, or characters don't match
                if (i == strs[j].length() || strs[j].charAt(i) != c) {
                    // The common prefix ends before index i
                    return firstString.substring(0, i);
                }
            }
        }

        // If the loop completes, the entire first string is the common prefix
        return firstString;
    }
}`
        },
        {
            id: 20,
            title: "有效的括号",
            url: "https://leetcode.cn/problems/valid-parentheses/",
            tags: ["栈", "字符串"],
            summary: "使用<strong>栈</strong> (<code>Stack</code>) 和哈希映射 (<code>Map</code>) 存储括号配对关系。遍历字符串 <code>s</code>：遇到左括号 (<code>(</code>, <code>[</code>, <code>{</code>)，将其压入栈。遇到右括号 (<code>)</code>, <code>]</code>, <code>}</code>)，检查栈是否为空，或者栈顶元素是否是当前右括号对应的左括号。若栈为空或不匹配，则字符串无效，返回 <code>false</code>。若匹配，则弹出栈顶元素。遍历结束后，检查栈是否为空。若为空，则字符串有效，返回 <code>true</code>；否则无效，返回 <code>false</code>。",
            code: `import java.util.Stack;
import java.util.Map;
import java.util.HashMap;

class Solution {
    /**
     * Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
     * An input string is valid if:
     * 1. Open brackets must be closed by the same type of brackets.
     * 2. Open brackets must be closed in the correct order.
     * 3. Every close bracket has a corresponding open bracket of the same type.
     *
     * @param s Input string containing brackets
     * @return True if the string is valid, false otherwise
     */
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        // Map to store the matching pairs of brackets
        Map<Character, Character> mapping = new HashMap<>();
        mapping.put(')', '(');
        mapping.put(']', '[');
        mapping.put('}', '{');

        for (char c : s.toCharArray()) {
            // If it's an opening bracket, push onto the stack
            if (mapping.containsValue(c)) { // Check if it's one of '(', '[', '{'
                stack.push(c);
            }
            // If it's a closing bracket
            else if (mapping.containsKey(c)) { // Check if it's one of ')', ']', '}'
                // Check if the stack is empty or the top element doesn't match
                if (stack.isEmpty() || stack.peek() != mapping.get(c)) {
                    return false; // Invalid sequence
                }
                // Matching bracket found, pop from stack
                stack.pop();
            }
            // Ignore other characters if any (though problem says only brackets)
        }

        // After iterating through the string, the stack should be empty for a valid string
        return stack.isEmpty();
    }
}`
        },
        // Problems 11-20 (corresponding to IDs 12, 13, 14, 15, 17, 19, 20, 21, 22, 23)
        {
            id: 13,
            title: "罗马数字转整数",
            url: "https://leetcode.cn/problems/roman-to-integer/",
            tags: ["哈希表", "数学", "字符串"],
            summary: "遍历罗马数字字符串 <code>s</code>。使用哈希表存储罗马字符对应的值。对当前字符 <code>s[i]</code>，检查其后的字符 <code>s[i+1]</code>。若 <code>value(s[i]) < value(s[i+1])</code>（如 <code>IV</code>），则从结果中减去 <code>value(s[i])</code>；否则，加上 <code>value(s[i])</code>。",
            code: `import java.util.HashMap;
import java.util.Map;

class Solution {
    /**
     * Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
     * ... (rules omitted)...
     * Given a roman numeral, convert it to an integer.
     *
     * @param s Roman numeral string (1 <= s.length <= 15, guaranteed to be valid)
     * @return The corresponding integer
     */
    public int romanToInt(String s) {
        Map<Character, Integer> romanMap = new HashMap<>();
        romanMap.put('I', 1);
        romanMap.put('V', 5);
        romanMap.put('X', 10);
        romanMap.put('L', 50);
        romanMap.put('C', 100);
        romanMap.put('D', 500);
        romanMap.put('M', 1000);

        int result = 0;
        int n = s.length();

        for (int i = 0; i < n; i++) {
            int currentValue = romanMap.get(s.charAt(i));

            // Check if the next character forms a special subtraction case
            if (i < n - 1 && currentValue < romanMap.get(s.charAt(i + 1))) {
                result -= currentValue; // Subtract the current value
            } else {
                result += currentValue; // Add the current value
            }
        }
        return result;
    }
}`
        },
        {
            id: 15,
            title: "三数之和",
            url: "https://leetcode.cn/problems/3sum/",
            tags: ["数组", "双指针", "排序"],
            summary: "先对数组 <code>nums</code> <strong>排序</strong>。遍历数组，固定第一个数 <code>nums[i]</code>。若 <code>nums[i] > 0</code>，后续不可能和为 0，可提前结束。跳过重复的 <code>nums[i]</code>。然后使用<strong>双指针</strong> <code>left = i + 1</code> 和 <code>right = n - 1</code> 在 <code>i</code> 之后查找。令 <code>target = -nums[i]</code>。当 <code>left < right</code> 时：若 <code>nums[left] + nums[right] == target</code>，记录结果，并移动 <code>left</code> 和 <code>right</code> 跳过重复元素；若和小于 <code>target</code>，<code>left++</code>；若和大于 <code>target</code>，<code>right--</code>。",
            code: `import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Solution {
    /**
     * Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
     * Notice that the solution set must not contain duplicate triplets.
     *
     * @param nums Integer array
     * @return A list of all unique triplets that sum to zero
     */
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        if (nums == null || nums.length < 3) {
            return result;
        }

        // 1. Sort the array
        Arrays.sort(nums);
        int n = nums.length;

        // 2. Iterate through the array, fixing the first element nums[i]
        for (int i = 0; i < n - 2; i++) {
            // Optimization: If the current number is positive, the sum cannot be zero
            if (nums[i] > 0) {
                break;
            }
            // Skip duplicate first elements
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }

            // 3. Use two pointers for the remaining part
            int left = i + 1;
            int right = n - 1;
            int target = -nums[i]; // The target sum for the two pointers

            while (left < right) {
                int sum = nums[left] + nums[right];

                if (sum == target) {
                    // Found a triplet
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));

                    // Skip duplicate second and third elements
                    while (left < right && nums[left] == nums[left + 1]) {
                        left++;
                    }
                    while (left < right && nums[right] == nums[right - 1]) {
                        right--;
                    }

                    // Move pointers to the next distinct elements
                    left++;
                    right--;
                } else if (sum < target) {
                    // Sum is too small, move left pointer
                    left++;
                } else {
                    // Sum is too large, move right pointer
                    right--;
                }
            }
        }
        return result;
    }
}`
        },
        {
            id: 17,
            title: "电话号码的字母组合",
            url: "https://leetcode.cn/problems/letter-combinations-of-a-phone-number/",
            tags: ["哈希表", "字符串", "回溯"],
            summary: "使用<strong>回溯</strong>算法。维护数字到字母的映射 <code>phoneMap</code>。定义递归函数 <code>backtrack(index, currentCombination)</code>。递归基：当 <code>index</code> 等于 <code>digits</code> 长度时，将 <code>currentCombination</code> 加入结果。递归步骤：获取当前数字 <code>digits[index]</code> 对应的字母串 <code>letters</code>。遍历 <code>letters</code> 中每个字母 <code>letter</code>，追加到 <code>currentCombination</code>，递归调用 <code>backtrack(index + 1, ...)</code>，然后从 <code>currentCombination</code> 中删除该字母（回溯）。",
            code: `import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

class Solution {
    // Mapping from digit to letters
    private Map<Character, String> phoneMap = new HashMap<>() {{
        put('2', "abc");
        put('3', "def");
        put('4', "ghi");
        put('5', "jkl");
        put('6', "mno");
        put('7', "pqrs");
        put('8', "tuv");
        put('9', "wxyz");
    }};

    private List<String> combinations = new ArrayList<>(); // Stores the final combinations
    private StringBuilder currentCombination = new StringBuilder(); // Stores the combination being built

    /**
     * Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.
     * Return the answer in any order.
     *
     * @param digits Input string of digits
     * @return List of all possible letter combinations
     */
    public List<String> letterCombinations(String digits) {
        if (digits == null || digits.length() == 0) {
            return combinations;
        }
        backtrack(digits, 0);
        return combinations;
    }

    /**
     * Backtracking function to generate combinations.
     * @param digits The input digit string
     * @param index The current index in the digits string being processed
     */
    private void backtrack(String digits, int index) {
        // Base case: If the current combination length equals the digits length, add it to the result
        if (index == digits.length()) {
            combinations.add(currentCombination.toString());
            return;
        }

        char digit = digits.charAt(index);
        String letters = phoneMap.get(digit);

        // Iterate through the letters corresponding to the current digit
        for (char letter : letters.toCharArray()) {
            // Make a choice: append the current letter
            currentCombination.append(letter);
            // Recurse for the next digit
            backtrack(digits, index + 1);
            // Undo the choice (backtrack): remove the last appended letter
            currentCombination.deleteCharAt(currentCombination.length() - 1);
        }
    }
}`
        },
        {
            id: 19,
            title: "删除链表的倒数第 N 个结点",
            url: "https://leetcode.cn/problems/remove-nth-node-from-end-of-list/",
            tags: ["链表", "双指针"],
            summary: "使用<strong>快慢指针</strong>。创建哑节点 <code>dummy</code> 指向 <code>head</code>。快指针 <code>fast</code> 先向前移动 <code>n</code> 步。然后，慢指针 <code>slow</code> 从 <code>dummy</code> 开始，与 <code>fast</code> 同时向前移动。当 <code>fast</code> 到达链表末尾 (<code>null</code>) 时，<code>slow</code> 正好指向待删除节点的前一个节点。执行删除操作 <code>slow.next = slow.next.next</code>。返回 <code>dummy.next</code>。",
            code: `/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    /**
     * Given the head of a linked list, remove the nth node from the end of the list and return its head.
     *
     * @param head The head of the linked list
     * @param n    The position from the end of the node to remove
     * @return The head of the modified linked list
     */
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // Create a dummy node to handle edge cases like removing the head
        ListNode dummy = new ListNode(0, head);
        ListNode fast = head;
        ListNode slow = dummy; // slow starts at dummy, pointing before the node to potentially remove

        // Move fast pointer n steps ahead
        for (int i = 0; i < n; i++) {
            if (fast != null) {
                fast = fast.next;
            } else {
                // This case should not happen based on constraints (n <= list size),
                // but good practice to handle.
                return head; // Or throw an exception
            }
        }

        // Move both pointers simultaneously until fast reaches the end
        while (fast != null) {
            fast = fast.next;
            slow = slow.next;
        }

        // slow now points to the node *before* the one to be removed
        // Remove the nth node from the end
        if (slow.next != null) {
            slow.next = slow.next.next;
        }

        // Return the head of the modified list (dummy.next)
        return dummy.next;
    }
}`
        },
        {
            id: 20,
            title: "有效的括号",
            url: "https://leetcode.cn/problems/valid-parentheses/",
            tags: ["栈", "字符串"],
            summary: "使用<strong>栈</strong> (<code>Stack</code>) 和哈希映射 (<code>Map</code>) 存储括号配对关系。遍历字符串 <code>s</code>：遇到左括号 (<code>(</code>, <code>[</code>, <code>{</code>)，将其压入栈。遇到右括号 (<code>)</code>, <code>]</code>, <code>}</code>)，检查栈是否为空，或者栈顶元素是否是当前右括号对应的左括号。若栈为空或不匹配，则字符串无效，返回 <code>false</code>。若匹配，则弹出栈顶元素。遍历结束后，检查栈是否为空。若为空，则字符串有效，返回 <code>true</code>；否则无效，返回 <code>false</code>。",
            code: `import java.util.Stack;
import java.util.Map;
import java.util.HashMap;

class Solution {
    /**
     * Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
     * An input string is valid if:
     * 1. Open brackets must be closed by the same type of brackets.
     * 2. Open brackets must be closed in the correct order.
     * 3. Every close bracket has a corresponding open bracket of the same type.
     *
     * @param s Input string containing brackets
     * @return True if the string is valid, false otherwise
     */
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        // Map to store the matching pairs of brackets
        Map<Character, Character> mapping = new HashMap<>();
        mapping.put(')', '(');
        mapping.put(']', '[');
        mapping.put('}', '{');

        for (char c : s.toCharArray()) {
            // If it's an opening bracket, push onto the stack
            if (mapping.containsValue(c)) { // Check if it's one of '(', '[', '{'
                stack.push(c);
            }
            // If it's a closing bracket
            else if (mapping.containsKey(c)) { // Check if it's one of ')', ']', '}'
                // Check if the stack is empty or the top element doesn't match
                if (stack.isEmpty() || stack.peek() != mapping.get(c)) {
                    return false; // Invalid sequence
                }
                // Matching bracket found, pop from stack
                stack.pop();
            }
            // Ignore other characters if any (though problem says only brackets)
        }

        // After iterating through the string, the stack should be empty for a valid string
        return stack.isEmpty();
    }
}`
        },
        {
            id: 21,
            title: "合并两个有序链表",
            url: "https://leetcode.cn/problems/merge-two-sorted-lists/",
            tags: ["递归", "链表"],
            summary: "方法1：<strong>迭代</strong>。创建哑节点 <code>dummy</code> 和当前指针 <code>current</code>。比较 <code>list1</code> 和 <code>list2</code> 的当前节点值。将值较小的节点连接到 <code>current.next</code>，并移动该链表的指针和 <code>current</code> 指针。当一个链表为空时，将另一个链表的剩余部分连接到 <code>current.next</code>。返回 <code>dummy.next</code>。\n方法2：<strong>递归</strong>。比较 <code>list1</code> 和 <code>list2</code> 的头节点。值较小的节点作为新头节点，其 <code>next</code> 指向对其余部分递归调用的结果。",
            code: `/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    /**
     * Merge two sorted linked lists and return it as a new sorted list.
     * The new list should be made by splicing together the nodes of the first two lists.
     *
     * @param list1 Head of the first sorted linked list
     * @param list2 Head of the second sorted linked list
     * @return Head of the merged sorted linked list
     */
    // Iterative Approach
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        // Create a dummy node to simplify the merging process
        ListNode dummy = new ListNode(-1);
        ListNode current = dummy; // Pointer to the current node in the merged list

        // Pointers to traverse list1 and list2
        ListNode p1 = list1;
        ListNode p2 = list2;

        // Iterate while both lists have nodes
        while (p1 != null && p2 != null) {
            if (p1.val <= p2.val) {
                current.next = p1; // Append the smaller node from list1
                p1 = p1.next;      // Move p1 forward
            } else {
                current.next = p2; // Append the smaller node from list2
                p2 = p2.next;      // Move p2 forward
            }
            current = current.next; // Move the current pointer forward in the merged list
        }

        // Append the remaining nodes from either list1 or list2
        if (p1 != null) {
            current.next = p1;
        } else {
            current.next = p2;
        }

        // Return the head of the merged list (dummy.next)
        return dummy.next;
    }
}`
        },
        {
            id: 22,
            title: "括号生成",
            url: "https://leetcode.cn/problems/generate-parentheses/",
            tags: ["字符串", "动态规划", "回溯"],
            summary: "使用<strong>回溯</strong>算法生成所有有效的括号组合。定义递归函数 <code>backtrack(currentString, openCount, closeCount, n)</code>。参数：<code>currentString</code> 当前构建的字符串，<code>openCount</code> 已用左括号数，<code>closeCount</code> 已用右括号数，<code>n</code> 目标括号对数。递归基：当 <code>currentString</code> 长度达到 <code>2*n</code> 时，将其加入结果列表。递归步骤：如果 <code>openCount < n</code>，可以添加左括号，递归调用 <code>backtrack(..., openCount + 1, ...)</code>，然后回溯。如果 <code>closeCount < openCount</code>，可以添加右括号，递归调用 <code>backtrack(..., closeCount + 1, ...)</code>，然后回溯。",
            code: `import java.util.ArrayList;
import java.util.List;

class Solution {
    private List<String> result = new ArrayList<>(); // Stores the final valid combinations

    /**
     * Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
     *
     * @param n The number of pairs of parentheses
     * @return A list of all valid parenthesis combinations
     */
    public List<String> generateParenthesis(int n) {
        backtrack(new StringBuilder(), 0, 0, n);
        return result;
    }

    /**
     * Backtracking function to generate parentheses.
     * @param current The StringBuilder holding the current combination being built
     * @param open    The count of open parentheses used so far
     * @param close   The count of close parentheses used so far
     * @param max     The target number of pairs (n)
     */
    private void backtrack(StringBuilder current, int open, int close, int max) {
        // Base case: If the length of the current string is 2 * max, we have a complete combination
        if (current.length() == max * 2) {
            result.add(current.toString());
            return;
        }

        // Condition to add an open parenthesis: if the count of open parentheses is less than max
        if (open < max) {
            current.append('('); // Make the choice
            backtrack(current, open + 1, close, max); // Recurse
            current.deleteCharAt(current.length() - 1); // Undo the choice (backtrack)
        }

        // Condition to add a close parenthesis: if the count of close parentheses is less than the count of open parentheses
        if (close < open) {
            current.append(')'); // Make the choice
            backtrack(current, open, close + 1, max); // Recurse
            current.deleteCharAt(current.length() - 1); // Undo the choice (backtrack)
        }
    }
}`
        },
        {
            id: 23,
            title: "合并K个升序链表",
            url: "https://leetcode.cn/problems/merge-k-sorted-lists/",
            tags: ["链表", "分治", "堆（优先队列）", "归并排序"],
            summary: "方法1：<strong>优先队列（最小堆）</strong>。将 <code>k</code> 个链表的头节点放入最小堆 (<code>PriorityQueue<ListNode></code>，按节点值排序)。循环：从堆中取出最小节点，加入结果链表，并将该节点的下一个节点（若存在）加入堆。时间 O(N log k)，空间 O(k)。\n方法2：<strong>分治（归并排序）</strong>。将 <code>k</code> 个链表两两合并，得到 <code>k/2</code> 个链表，再两两合并... 直到合并为一个链表。时间 O(N log k)，空间 O(log k)（递归栈）。",
            code: `import java.util.PriorityQueue;
import java.util.Comparator;
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    /**
     * Merge k sorted linked lists and return it as one sorted list.
     * Analyze and describe its complexity.
     *
     * @param lists Array of sorted linked lists
     * @return Head of the merged sorted linked list
     */
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists == null || lists.length == 0) {
            return null;
        }

        // Create a min-heap (PriorityQueue) based on node values
        PriorityQueue<ListNode> minHeap = new PriorityQueue<>(Comparator.comparingInt(node -> node.val));

        // Add the head node of each non-empty list to the min-heap
        for (ListNode head : lists) {
            if (head != null) {
                minHeap.add(head);
            }
        }

        ListNode dummy = new ListNode(-1); // Dummy head for the result list
        ListNode current = dummy; // Pointer to the current node in the result list

        // Continuously extract the minimum node from the heap and add to the result list
        while (!minHeap.isEmpty()) {
            ListNode smallest = minHeap.poll(); // Get the node with the smallest value
            current.next = smallest;           // Append it to the result list
            current = current.next;           // Move the current pointer

            // If the extracted node has a next node, add it to the heap
            if (smallest.next != null) {
                minHeap.add(smallest.next);
            }
        }

        return dummy.next; // Return the head of the merged list
    }
}
// ListNode class definition assumed to be available
// class ListNode { int val; ListNode next; ... }`
        },
        // Problems from the second document (IDs 56-74)
        {
            id: 56,
            title: "合并区间",
            url: "https://leetcode.cn/problems/merge-intervals/",
            tags: ["数组", "排序"],
            summary: "先按区间的<strong>起始时间</strong>对区间列表 <code>intervals</code> 进行排序。然后遍历排序后的区间，维护一个合并后的结果列表 <code>mergedIntervals</code>。对于当前区间，如果结果列表为空或当前区间的起始时间大于结果列表中最后一个区间的结束时间，则将其加入结果列表。否则，更新结果列表中最后一个区间的结束时间为 <code>max(原结束时间, 当前区间结束时间)</code>。",
            code: `import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.Comparator; // 需要导入 Comparator

class Solution {
    // Method to merge overlapping intervals.
    public int[][] merge(int[][] intervals) {
        if (intervals == null || intervals.length == 0) {
            return new int[0][];
        }
        // Sort the intervals by their starting times.
        // 使用 Comparator.comparingInt 来指定排序依据
        Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));

        // List that holds the merged intervals.
        List<int[]> mergedIntervals = new ArrayList<>();
        // Add the first interval to the list as starting interval for merging.
        mergedIntervals.add(intervals[0]); // 直接添加第一个区间

        // Loop through all the intervals starting from the second one.
        for (int i = 1; i < intervals.length; ++i) {
            // Get the start and end times of the current interval.
            int start = intervals[i][0]; // 获取当前区间的起始
            int end = intervals[i][1];   // 获取当前区间的结束

            // Get the last interval in the merged list.
            int[] lastMergedInterval = mergedIntervals.get(mergedIntervals.size() - 1);

            // Check if there is an overlap with the last interval in the merged list.
            // 使用 lastMergedInterval[1] 获取最后一个合并区间的结束时间
            if (lastMergedInterval[1] < start) {
                // No overlap, so we can add the current interval as it is.
                mergedIntervals.add(intervals[i]);
            } else {
                // Overlap exists, so we extend the last interval's end time.
                // 更新最后一个合并区间的结束时间
                lastMergedInterval[1] = Math.max(lastMergedInterval[1], end);
            }
        }
        // Convert the merged intervals list to a 2D array and return it.
        return mergedIntervals.toArray(new int[mergedIntervals.size()][]);
    }
}`
        },
        {
            id: 57,
            title: "插入区间",
            url: "https://leetcode.cn/problems/insert-interval/",
            tags: ["数组", "区间"],
            summary: "将新区间 <code>newInterval</code> 添加到现有区间列表 <code>intervals</code>。然后对整个列表按<strong>起始时间排序</strong>。最后，应用<strong>合并区间</strong>的逻辑（同第 56 题）来合并所有重叠的区间。",
            code: `import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Comparator; // 需要导入 Comparator

class Solution {
    // Function to insert a new interval into an existing list of intervals
    public int[][] insert(int[][] intervals, int[] newInterval) {
        // Initialize an expanded list to hold the existing intervals and the new interval
        List<int[]> expandedIntervalsList = new ArrayList<>(Arrays.asList(intervals));
        expandedIntervalsList.add(newInterval);

        // Convert list back to array for sorting
        int[][] expandedIntervals = expandedIntervalsList.toArray(new int[0][]);

        // Merge overlapping intervals and return the result
        return merge(expandedIntervals);
    }

    // Helper function to merge overlapping intervals (same as problem 56)
    private int[][] merge(int[][] intervals) {
         if (intervals == null || intervals.length == 0) {
            return new int[0][];
        }
        // Sort the intervals based on the starting times
        Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));

        // List to hold the merged intervals
        List<int[]> mergedIntervals = new ArrayList<>();
        // Add the first interval to the list as initialization
        mergedIntervals.add(intervals[0]);

        // Iterate through each interval and merge if necessary
        for (int i = 1; i < intervals.length; ++i) {
            // Get the start and end times of the current interval
            int start = intervals[i][0];
            int end = intervals[i][1];

            // Get the last interval in the list.
            int[] lastMergedInterval = mergedIntervals.get(mergedIntervals.size() - 1);
            int lastEnd = lastMergedInterval[1];

            // If the current interval does not overlap with the previous, simply add it
            if (lastEnd < start) {
                mergedIntervals.add(intervals[i]);
            } else {
                // Otherwise, merge the current interval with the previous one by updating the end time
                lastMergedInterval[1] = Math.max(lastEnd, end);
            }
        }
        // Convert the list back into an array and return
        return mergedIntervals.toArray(new int[mergedIntervals.size()][]);
    }
}`
        },
        {
            id: 58,
            title: "最后一个单词的长度",
            url: "https://leetcode.cn/problems/length-of-last-word/",
            tags: ["字符串"],
            summary: "从字符串 <code>s</code> 的<strong>末尾向前</strong>遍历。使用计数器 <code>count</code> 记录单词长度。遇到非空格字符时，<code>count++</code>。遇到空格时，如果 <code>count > 0</code>（说明已经开始计数最后一个单词），则表示最后一个单词结束，返回 <code>count</code>。遍历结束后（处理没有前导空格的情况）也返回 <code>count</code>。可以先 <code>trim()</code> 去除首尾空格简化处理。",
            code: `class Solution {
    public int lengthOfLastWord(String s) {
        int count = 0;
        // Trim trailing spaces first for simpler logic
        s = s.trim();
        // Iterate from the end of the trimmed string
        for (int i = s.length() - 1; i >= 0; i--) {
            // If it's not a space, increment count
            if (s.charAt(i) != ' ') {
                count++;
            } else {
                // If it's a space, we've found the end of the last word
                break;
            }
        }
        return count; // Return the length of the last word
    }
}`
        },
        {
            id: 61,
            title: "旋转链表",
            url: "https://leetcode.cn/problems/rotate-list/",
            tags: ["链表", "双指针"],
            summary: "将链表向右旋转 <code>k</code> 个位置。先遍历链表计算长度 <code>length</code>，并将链表<strong>首尾相连</strong>形成环。计算实际旋转次数 <code>k = k % length</code>。找到新的尾节点，它位于原链表的第 <code>length - k - 1</code> 个位置（0-indexed）。断开新尾节点的 <code>next</code> 指针，其下一个节点即为新的头节点。返回新头节点。",
            code: `/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        // Handle edge cases: empty list, single node list, or k=0
        if (head == null || head.next == null || k == 0) {
            return head;
        }

        // 1. Calculate the length and find the tail node
        ListNode current = head;
        int length = 1;
        while (current.next != null) {
            current = current.next;
            length++;
        }

        // 2. Connect the tail to the head to form a cycle
        current.next = head;

        // 3. Calculate the actual rotation steps needed (k can be larger than length)
        int stepsToNewTail = length - (k % length) - 1;

        // 4. Find the new tail node
        ListNode newTail = head;
        for (int i = 0; i < stepsToNewTail; i++) {
            newTail = newTail.next;
        }

        // 5. The new head is the node after the new tail
        ListNode newHead = newTail.next;

        // 6. Break the cycle by setting the new tail's next to null
        newTail.next = null;

        return newHead; // Return the new head of the rotated list
    }
}`
        },
        {
            id: 63,
            title: "不同路径 II",
            url: "https://leetcode.cn/problems/unique-paths-ii/",
            tags: ["数组", "动态规划", "矩阵"],
            summary: "计算从左上角到右下角的路径数，网格中含障碍物。使用<strong>动态规划</strong>。创建 <code>dp</code> 数组，<code>dp[i][j]</code> 表示到达 <code>(i, j)</code> 的路径数。初始化第一行和第一列：若无障碍物，路径数为 1，遇到障碍物则后续为 0。状态转移：若 <code>obstacleGrid[i][j] == 0</code>，则 <code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code>；若为障碍物，<code>dp[i][j] = 0</code>。最终答案为 <code>dp[m-1][n-1]</code>。可优化空间至 O(n)。",
            code: `class Solution {
    // Function to calculate the unique paths in a grid with obstacles
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        // Get the dimensions of the grid
        int numRows = obstacleGrid.length;
        if (numRows == 0) return 0; // Handle empty grid
        int numCols = obstacleGrid[0].length;
        if (numCols == 0) return 0; // Handle empty grid

        // If start or end is an obstacle, return 0
        if (obstacleGrid[0][0] == 1 || obstacleGrid[numRows - 1][numCols - 1] == 1) {
            return 0;
        }

        // Initialize a DP table (can optimize to O(n) space)
        int[][] dp = new int[numRows][numCols];

        // Initialize the starting cell
        dp[0][0] = 1; // Only 1 way to reach the start if it's not an obstacle

        // Initialize the first column
        for (int i = 1; i < numRows; ++i) {
            if (obstacleGrid[i][0] == 0) {
                dp[i][0] = dp[i - 1][0];
            } // else dp[i][0] remains 0
        }

        // Initialize the first row
        for (int j = 1; j < numCols; ++j) {
            if (obstacleGrid[0][j] == 0) {
                dp[0][j] = dp[0][j - 1];
            } // else dp[0][j] remains 0
        }

        // Fill the rest of the DP table
        for (int i = 1; i < numRows; ++i) {
            for (int j = 1; j < numCols; ++j) {
                // If the current cell is not an obstacle
                if (obstacleGrid[i][j] == 0) {
                    // Number of paths is the sum of paths from above and from the left
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                }
                // If the current cell is an obstacle, dp[i][j] remains 0
            }
        }

        // Return the number of unique paths to the bottom-right corner
        return dp[numRows - 1][numCols - 1];
    }
}`
        },
        {
            id: 64,
            title: "最小路径和",
            url: "https://leetcode.cn/problems/minimum-path-sum/",
            tags: ["数组", "动态规划", "矩阵"],
            summary: "计算从左上角到右下角的最小路径和，只能向下或向右移动。使用<strong>动态规划</strong>。创建 <code>dp</code> 数组，<code>dp[i][j]</code> 表示到达 <code>(i, j)</code> 的最小路径和。初始化 <code>dp[0][0] = grid[0][0]</code>。填充第一行 <code>dp[0][j] = dp[0][j-1] + grid[0][j]</code> 和第一列 <code>dp[i][0] = dp[i-1][0] + grid[i][0]</code>。状态转移：<code>dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]</code>。最终答案为 <code>dp[m-1][n-1]</code>。可原地修改 <code>grid</code> 或优化空间至 O(n)。",
            code: `class Solution {
    /**
     * Method to find the minimum path sum in a grid.
     * @param grid The input grid of non-negative integers.
     * @return The minimum path sum from the top-left to the bottom-right corner.
     */
    public int minPathSum(int[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        int m = grid.length;
        int n = grid[0].length;

        // Use the grid itself for DP to save space (in-place modification)
        // dp[i][j] will store the minimum path sum to reach cell (i, j)

        // Initialize the first row (only horizontal moves possible)
        for (int j = 1; j < n; ++j) {
            grid[0][j] += grid[0][j - 1];
        }

        // Initialize the first column (only vertical moves possible)
        for (int i = 1; i < m; ++i) {
            grid[i][0] += grid[i - 1][0];
        }

        // Fill in the rest of the grid using DP relation
        for (int i = 1; i < m; ++i) {
            for (int j = 1; j < n; ++j) {
                // Minimum path sum to (i, j) is grid[i][j] + min(path from top, path from left)
                grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
            }
        }

        // The bottom-right cell contains the minimum path sum
        return grid[m - 1][n - 1];
    }
}`
        },
        {
            id: 66,
            title: "加一",
            url: "https://leetcode.cn/problems/plus-one/",
            tags: ["数组", "数学"],
            summary: "模拟整数加一。从数组 <code>digits</code> 的<strong>末尾</strong>（最低位）开始向前遍历。将当前位加一，并对 10 取模。如果当前位不为 0，说明没有进位，直接返回更新后的 <code>digits</code>。如果当前位变为 0，则需要进位，继续向前遍历。如果遍历完所有位（最高位也产生进位，如 <code>[9,9]</code> -> <code>[0,0]</code>），则创建一个长度加一的新数组，首位设为 1，其余为 0，并返回新数组。",
            code: `class Solution {
    public int[] plusOne(int[] digits) {
        // Get the number of digits in the array
        int length = digits.length;

        // Iterate over the digits starting from the least significant digit (LSD)
        for (int i = length - 1; i >= 0; --i) {
            // Increase the current digit by one
            digits[i]++;
            // Take modulo 10 to handle carry-over
            digits[i] %= 10;

            // If the digit is not 0 after increment and modulo, it means no carry-over to the next digit
            // We can return the updated digits array immediately
            if (digits[i] != 0) {
                return digits;
            }
            // Otherwise, carry-over happens, continue the loop for the next digit
        }

        // If we're here, it means that we had a carry out from the most significant digit (MSD)
        // which requires us to expand the array. Example: 999 + 1 = 1000
        // Create a new array with one additional digit
        int[] result = new int[length + 1];
        result[0] = 1; // Set the first element to 1, the rest are default to 0
        // Return the result which has an additional digit
        return result;
    }
}`
        },
        {
            id: 67,
            title: "二进制求和",
            url: "https://leetcode.cn/problems/add-binary/",
            tags: ["位运算", "数学", "字符串", "模拟"],
            summary: "模拟二进制加法。从两个字符串 <code>a</code> 和 <code>b</code> 的<strong>末尾</strong>开始，逐位相加，同时考虑进位 <code>carry</code>。使用 <code>StringBuilder</code> 存储结果。循环条件是两个索引都未越界或 <code>carry</code> 不为 0。每次计算当前位的和 <code>sum = bit_a + bit_b + carry</code>。将 <code>sum % 2</code> 追加到结果的<strong>前面</strong>（或最后反转）。更新进位 <code>carry = sum / 2</code>。最后返回结果字符串。",
            code: `public class Solution {
    public String addBinary(String a, String b) {
        StringBuilder result = new StringBuilder();
        int indexA = a.length() - 1; // Pointer for string a
        int indexB = b.length() - 1; // Pointer for string b
        int carry = 0; // Carry-over

        // Loop until both indices are out of bounds and there is no carry left
        while (indexA >= 0 || indexB >= 0 || carry > 0) {
            int sum = carry; // Start with the carry

            // Add the current bit from string a if index is valid
            if (indexA >= 0) {
                sum += a.charAt(indexA) - '0'; // Convert char '0'/'1' to int 0/1
                indexA--; // Move pointer
            }

            // Add the current bit from string b if index is valid
            if (indexB >= 0) {
                sum += b.charAt(indexB) - '0'; // Convert char '0'/'1' to int 0/1
                indexB--; // Move pointer
            }

            // Append the current bit of the result (sum modulo 2)
            result.append(sum % 2);

            // Calculate the new carry (sum divided by 2)
            carry = sum / 2;
        }

        // Since we appended bits from right to left, reverse the result string
        return result.reverse().toString();
    }
}`
        },
        {
            id: 68,
            title: "文本左右对齐",
            url: "https://leetcode.cn/problems/text-justification/",
            tags: ["数组", "字符串", "模拟"],
            summary: "模拟文本排版。逐行处理单词。贪心选择当前行能放下的最多单词。计算该行需要的总空格数。<strong>对于非最后一行</strong>：计算单词间的平均空格数 <code>spacesBetweenWords</code> 和需要额外分配到左边间隙的空格数 <code>extraSpacesCount</code>。构建行字符串，在单词间插入计算好的空格。<strong>对于最后一行或只有一个单词的行</strong>：单词间只加一个空格，末尾填充空格直到达到 <code>maxWidth</code>。",
            code: `import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<String> fullJustify(String[] words, int maxWidth) {
        List<String> justifiedText = new ArrayList<>();
        int index = 0;
        int numOfWords = words.length;

        while (index < numOfWords) {
            List<String> currentLineWords = new ArrayList<>();
            int currentLineLength = 0; // Length of words only in the current line
            int lineStartIndex = index;

            // Determine how many words fit in the current line
            while (index < numOfWords && currentLineLength + currentLineWords.size() + words[index].length() <= maxWidth) {
                currentLineWords.add(words[index]);
                currentLineLength += words[index].length();
                index++;
            }

            StringBuilder justifiedLine = new StringBuilder();
            int numWordsInLine = currentLineWords.size();
            int totalSpaces = maxWidth - currentLineLength;

            // Handle the last line or lines with only one word (left-justify)
            if (index == numOfWords || numWordsInLine == 1) {
                justifiedLine.append(String.join(" ", currentLineWords));
                // Append trailing spaces
                while (justifiedLine.length() < maxWidth) {
                    justifiedLine.append(" ");
                }
            } else { // Handle middle lines (fully justify)
                int numGaps = numWordsInLine - 1;
                int spacesBetweenWords = totalSpaces / numGaps;
                int extraSpacesCount = totalSpaces % numGaps;

                for (int wordIndex = 0; wordIndex < numWordsInLine; wordIndex++) {
                    justifiedLine.append(currentLineWords.get(wordIndex));
                    if (wordIndex < numGaps) { // Don't add spaces after the last word
                        // Add base spaces
                        for (int s = 0; s < spacesBetweenWords; s++) {
                            justifiedLine.append(" ");
                        }
                        // Add extra spaces to the left gaps
                        if (extraSpacesCount > 0) {
                            justifiedLine.append(" ");
                            extraSpacesCount--;
                        }
                    }
                }
            }
            justifiedText.add(justifiedLine.toString());
        }
        return justifiedText;
    }
}`
        },
        {
            id: 69,
            title: "x 的平方根 ",
            url: "https://leetcode.cn/problems/sqrtx/",
            tags: ["数学", "二分查找"],
            summary: "计算非负整数 <code>x</code> 的<strong>整数平方根</strong>。使用<strong>二分查找</strong>。搜索范围为 <code>[0, x]</code>。在循环 <code>left <= right</code> 中，计算中间值 <code>mid</code> (使用 <code>long</code> 避免 <code>mid*mid</code> 溢出)。比较 <code>mid * mid</code> 与 <code>x</code>：若 <code>mid * mid <= x</code>，则 <code>mid</code> 是一个可能的解，记录 <code>mid</code> 到 <code>result</code>，并尝试更大的值 (<code>left = mid + 1</code>)；若 <code>mid * mid > x</code>，则解在左半部分 (<code>right = mid - 1</code>)。循环结束后返回 <code>result</code>。",
            code: `class Solution {
    public int mySqrt(int x) {
        // Handle base cases 0 and 1
        if (x == 0 || x == 1) {
            return x;
        }

        long left = 0; // Use long to avoid potential overflow with mid*mid
        long right = x;
        int result = 0; // Store the potential integer square root

        while (left <= right) { // Standard binary search condition
            long mid = left + (right - left) / 2; // Calculate midpoint

            // Check if mid*mid is less than or equal to x
            // Use long for multiplication to prevent overflow
            if (mid * mid <= x) {
                // If it is, mid is a possible candidate for the integer square root.
                // Store it and try searching in the right half for a potentially larger root.
                result = (int) mid; // Update result
                left = mid + 1;     // Move left boundary
            } else {
                // If mid*mid is greater than x, the square root must be in the left half.
                right = mid - 1;    // Move right boundary
            }
        }

        // After the loop, 'result' holds the largest integer whose square is less than or equal to x.
        return result;
    }
}`
        },
        {
            id: 70,
            title: "爬楼梯",
            url: "https://leetcode.cn/problems/climbing-stairs/",
            tags: ["记忆化搜索", "数学", "动态规划"],
            summary: "爬 <code>n</code> 级楼梯，每次可爬 1 或 2 级，求不同方法数。这是<strong>斐波那契数列</strong>问题。方法：<strong>动态规划 (空间优化)</strong>。到达第 <code>i</code> 级的方法数等于到达第 <code>i-1</code> 级和第 <code>i-2</code> 级的方法数之和。使用两个变量 <code>prev</code> (代表 <code>dp[i-2]</code>) 和 <code>curr</code> (代表 <code>dp[i-1]</code>) 迭代计算。初始化 <code>prev = 1</code> (1 级台阶), <code>curr = 2</code> (2 级台阶)。从 <code>i = 3</code> 循环到 <code>n</code>，计算 <code>next = prev + curr</code>，然后更新 <code>prev = curr</code>, <code>curr = next</code>。最终返回 <code>curr</code> (即 <code>dp[n]</code>)。注意处理 <code>n <= 2</code> 的基本情况。",
            code: `class Solution {
    // This method calculates the number of distinct ways to climb to the top.
    public int climbStairs(int n) {
        // Base cases: if n is 1 or 2, return n directly.
        if (n <= 2) {
            return n;
        }

        // Initialize variables to store the number of ways for the previous two steps.
        // 'first' corresponds to ways to reach step (i-2) -> initialized for step 1
        // 'second' corresponds to ways to reach step (i-1) -> initialized for step 2
        int first = 1;  // Ways to reach step 1 (dp[1])
        int second = 2; // Ways to reach step 2 (dp[2])

        // Loop from the 3rd step up to the nth step
        for (int i = 3; i <= n; i++) {
            // Calculate the number of ways to reach the current step 'i'
            // currentWays = dp[i-1] + dp[i-2]
            int currentWays = second + first;

            // Update the variables for the next iteration
            // The previous second becomes the new first
            first = second;
            // The currentWays becomes the new second
            second = currentWays;
        }

        // 'second' now holds the total ways to reach the nth step (dp[n])
        return second;
    }
}`
        },
        {
            id: 71,
            title: "简化路径",
            url: "https://leetcode.cn/problems/simplify-path/",
            tags: ["栈", "字符串"],
            summary: "简化 Unix 风格的绝对路径。使用<strong>栈</strong> (<code>Deque</code>) 模拟目录导航。按 <code>/</code> 分割路径字符串 <code>path</code>。遍历分割后的各部分 <code>segment</code>：若 <code>segment</code> 为空或 <code>.</code>，忽略；若为 <code>..</code>，且栈不为空，则弹出栈顶（向上返回一级）；若为其他（目录名），则压入栈。最后，将栈中元素用 <code>/</code> 连接起来，并在最前面加上 <code>/</code>。若栈为空，返回 <code>/</code>。",
            code: `import java.util.ArrayDeque;
import java.util.Deque;
import java.util.StringJoiner; // 用于更方便地拼接字符串

class Solution {
    public String simplifyPath(String path) {
        // Use a deque as a stack to hold the directory names.
        Deque<String> stack = new ArrayDeque<>();

        // Split the path by "/" and iterate over the segments.
        for (String segment : path.split("/")) {
            // If the segment is empty or a single ".", just ignore it.
            if (segment.isEmpty() || ".".equals(segment)) {
                continue;
            }
            // If the segment is "..", pop an element from the stack if available (move up one level).
            if ("..".equals(segment)) {
                if (!stack.isEmpty()) {
                    stack.pollLast(); // Use pollLast to remove from the end (acting as stack top)
                }
            } else {
                // Push the valid directory name onto the stack (move down one level).
                stack.offerLast(segment); // Use offerLast to add to the end (acting as stack push)
            }
        }

        // If the stack is empty after processing, the simplified path is just "/"
        if (stack.isEmpty()) {
            return "/";
        }

        // Join all the elements in the stack with "/", prepended by a "/" to form the simplified path.
        // Use StringJoiner for efficient and clean string building.
        StringJoiner sj = new StringJoiner("/", "/", ""); // Prefix "/", Delimiter "/", Suffix ""
        while (!stack.isEmpty()) {
            sj.add(stack.pollFirst()); // Poll from the front to maintain the correct directory order
        }

        // Return the simplified absolute path.
        return sj.toString();
    }
}`
        },
        {
            id: 72,
            title: "编辑距离",
            url: "https://leetcode.cn/problems/edit-distance/",
            tags: ["字符串", "动态规划"],
            summary: "计算将 <code>word1</code> 转换为 <code>word2</code> 所需的最少操作（插入、删除、替换）次数。使用<strong>动态规划</strong>。定义 <code>dp[i][j]</code> 为 <code>word1</code> 的前 <code>i</code> 字符转换为 <code>word2</code> 的前 <code>j</code> 字符所需的最少操作数。初始化：<code>dp[0][j] = j</code> (插入 j 次)，<code>dp[i][0] = i</code> (删除 i 次)。状态转移：若 <code>word1[i-1] == word2[j-1]</code>，则 <code>dp[i][j] = dp[i-1][j-1]</code> (无需操作)；否则，<code>dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1</code> (分别对应删除、插入、替换操作)。返回 <code>dp[m][n]</code>。",
            code: `class Solution {
    public int minDistance(String word1, String word2) {
        // Lengths of the input strings
        int lenWord1 = word1.length();
        int lenWord2 = word2.length();

        // Create a 2D array to store the subproblem results
        // dpTable[i][j] will be the min distance between word1[0...i-1] and word2[0...j-1]
        int[][] dpTable = new int[lenWord1 + 1][lenWord2 + 1];

        // Initialize the first row and first column
        // Distance from empty string to word2[0...j-1] is j insertions
        for (int j = 0; j <= lenWord2; ++j) {
            dpTable[0][j] = j;
        }
        // Distance from word1[0...i-1] to empty string is i deletions
        for (int i = 0; i <= lenWord1; ++i) {
            dpTable[i][0] = i;
        }

        // Fill out the dpTable for all subproblems
        for (int i = 1; i <= lenWord1; ++i) {
            for (int j = 1; j <= lenWord2; ++j) {
                // If the characters at the current positions match (using 0-based index for strings)
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    // No operation needed, cost is the same as for prefixes ending at i-1, j-1
                    dpTable[i][j] = dpTable[i - 1][j - 1];
                } else {
                    // If the characters are different, consider three operations:
                    // 1. Insert: Transform word1[0...i-1] to word2[0...j-2], then insert word2[j-1]. Cost = dpTable[i][j-1] + 1
                    int insertOps = dpTable[i][j - 1];
                    // 2. Delete: Transform word1[0...i-2] to word2[0...j-1], then delete word1[i-1]. Cost = dpTable[i-1][j] + 1
                    int deleteOps = dpTable[i - 1][j];
                    // 3. Replace: Transform word1[0...i-2] to word2[0...j-2], then replace word1[i-1] with word2[j-1]. Cost = dpTable[i-1][j-1] + 1
                    int replaceOps = dpTable[i - 1][j - 1];

                    // Take the minimum of the three operations and add 1 for the cost of the operation
                    dpTable[i][j] = Math.min(insertOps, Math.min(deleteOps, replaceOps)) + 1;
                }
            }
        }

        // The bottom-right cell gives the final result: min distance between word1 and word2
        return dpTable[lenWord1][lenWord2];
    }
}`
        },
        {
            id: 73,
            title: "矩阵置零",
            url: "https://leetcode.cn/problems/set-matrix-zeroes/",
            tags: ["数组", "哈希表", "矩阵"],
            summary: "原地将包含 0 的元素的整行和整列都置为 0。方法：使用<strong>第一行和第一列</strong>作为标记空间。先检查第一行和第一列自身是否包含 0，用布尔变量 <code>firstRowHasZero</code> 和 <code>firstColHasZero</code> 记录。然后遍历矩阵的剩余部分 (<code>i</code> 从 1 开始, <code>j</code> 从 1 开始)。若 <code>matrix[i][j] == 0</code>，则将对应的第一行和第一列标记置零：<code>matrix[i][0] = 0</code>, <code>matrix[0][j] = 0</code>。再次遍历剩余部分，若 <code>matrix[i][0] == 0</code> 或 <code>matrix[0][j] == 0</code>，则将 <code>matrix[i][j]</code> 置零。最后根据 <code>firstRowHasZero</code> 和 <code>firstColHasZero</code> 决定是否将第一行和第一列置零。",
            code: `class Solution {
    public void setZeroes(int[][] matrix) {
        int rowCount = matrix.length; // number of rows
        if (rowCount == 0) return; // Handle empty matrix
        int colCount = matrix[0].length; // number of columns
        if (colCount == 0) return; // Handle empty matrix

        boolean firstRowHasZero = false; // flag for first row
        boolean firstColHasZero = false; // flag for first column

        // 1. Check if the first row contains a zero
        for (int col = 0; col < colCount; ++col) {
            if (matrix[0][col] == 0) {
                firstRowHasZero = true;
                break;
            }
        }

        // 2. Check if the first column contains a zero
        for (int row = 0; row < rowCount; ++row) {
            if (matrix[row][0] == 0) {
                firstColHasZero = true;
                break;
            }
        }

        // 3. Use the first row and column as markers for the rest of the matrix
        // Iterate through the matrix starting from (1, 1)
        for (int row = 1; row < rowCount; ++row) {
            for (int col = 1; col < colCount; ++col) {
                // If an element is zero, mark its corresponding first row and first column element
                if (matrix[row][col] == 0) {
                    matrix[row][0] = 0; // Mark row i
                    matrix[0][col] = 0; // Mark col j
                }
            }
        }

        // 4. Iterate over the matrix again (excluding first row/col) using the markers
        // and set the elements to 0 accordingly.
        for (int row = 1; row < rowCount; ++row) {
            for (int col = 1; col < colCount; ++col) {
                if (matrix[row][0] == 0 || matrix[0][col] == 0) {
                    matrix[row][col] = 0;
                }
            }
        }

        // 5. Nullify the first row if needed based on the initial check
        if (firstRowHasZero) {
            for (int col = 0; col < colCount; ++col) {
                matrix[0][col] = 0;
            }
        }

        // 6. Nullify the first column if needed based on the initial check
        if (firstColHasZero) {
            for (int row = 0; row < rowCount; ++row) {
                matrix[row][0] = 0;
            }
        }
    }
}`
        },
        {
            id: 74,
            title: "搜索二维矩阵",
            url: "https://leetcode.cn/problems/search-a-2d-matrix/",
            tags: ["数组", "二分查找", "矩阵"],
            summary: "在 m x n 矩阵中搜索目标值 <code>target</code>。矩阵特性：每行从左到右升序，每行的第一个整数大于前一行的最后一个整数。可以将矩阵视为一个<strong>逻辑上排序的一维数组</strong>，长度为 <code>m * n</code>。然后应用<strong>二分查找</strong>。将一维索引 <code>mid</code> 转换为二维索引 <code>(row, col)</code>：<code>row = mid / n</code>, <code>col = mid % n</code>。比较 <code>matrix[row][col]</code> 与 <code>target</code>，调整二分查找的 <code>left</code> 和 <code>right</code> 指针。时间复杂度 O(log(m*n))。",
            code: `class Solution {
    /**
     * Searches for a target value in a sorted 2D matrix.
     * The matrix has properties: rows are sorted left-to-right,
     * and the first element of each row is greater than the last element of the previous row.
     *
     * @param matrix The 2D matrix to search in.
     * @param target The integer to search for.
     * @return True if the target is found, false otherwise.
     */
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return false; // Handle empty or invalid matrix
        }
        int rows = matrix.length;
        int cols = matrix[0].length;

        // Treat the matrix as a sorted 1D array with indices from 0 to rows * cols - 1
        int left = 0;
        int right = rows * cols - 1;

        while (left <= right) { // Standard binary search condition
            int mid = left + (right - left) / 2; // Calculate midpoint index to avoid overflow

            // Convert 1D midpoint index to 2D row and column indices
            int midValue = matrix[mid / cols][mid % cols];

            if (midValue == target) {
                return true; // Target found
            } else if (midValue < target) {
                left = mid + 1; // Target is in the right half
            } else {
                right = mid - 1; // Target is in the left half
            }
        }

        // Target not found after binary search
        return false;
    }
}`
        }

    ]

    // --- Add Hot 100 tag dynamically ---
    problemsData.forEach(problem => {
        if (hot100Titles.has(problem.title)) {
            if (!problem.tags.includes("Hot 100")) { // Avoid duplicates if already present
                problem.tags.push("Hot 100");
            }
        } else {
            // Ensure "Hot 100" is removed if the title is not in the list
            const index = problem.tags.indexOf("Hot 100");
            if (index > -1) {
                problem.tags.splice(index, 1);
            }
        }
    });


    // --- DOM Elements ---
    const tableBody = document.getElementById('problemsTable').querySelector('tbody');
    const searchInput = document.getElementById('searchInput');
    const tagFilterContainer = document.getElementById('tagFilterContainer');
    const clearTagFilterButton = document.getElementById('clearTagFilter');
    const noResultsRow = document.getElementById('noResultsRow');
    const sortHeader = document.getElementById('sortHeader');
    const sortIcon = document.getElementById('sortIcon');

    // --- State Variables ---
    let currentSort = 'asc'; // Initial sort order ('asc' or 'desc')
    let currentSearchTerm = '';
    // Use a Set to store multiple selected tags
    let selectedTags = new Set(); // Changed from currentSelectedTag

    // --- Functions ---

    /**
     * Sets up the tag filter buttons based on available tags in the data.
     */
    function setupTagFilters() {
        tagFilterContainer.innerHTML = ''; // Clear existing buttons except the template
        tagFilterContainer.appendChild(clearTagFilterButton); // Re-add clear button

        const tags = new Set();
        problemsData.forEach(p => p.tags.forEach(tag => tags.add(tag)));
        // Sort tags, potentially placing "Hot 100" first or last if desired
        const sortedTags = Array.from(tags).sort((a, b) => {
            if (a === 'Hot 100') return -1; // Put Hot 100 first
            if (b === 'Hot 100') return 1;
            return a.localeCompare(b); // Sort others alphabetically
        });


        sortedTags.forEach(tag => {
            const button = document.createElement('button');
            button.textContent = tag;
            button.dataset.tag = tag; // Store tag in data attribute
            // Determine base color class based on tag type
            const baseColorClass = tag === 'Hot 100' ? 'tag-hot100 bg-blue-100 text-blue-800' : 'tag-default bg-green-100 text-green-800';
            button.classList.add(
                'tag-filter-button', 'px-3', 'py-1', // Base classes
                'text-xs', 'font-medium', 'rounded-full',
                'hover:opacity-80', // Hover effect
                ...baseColorClass.split(' ') // Apply base color
            );

            // Add click listener to toggle tag selection
            button.addEventListener('click', () => toggleTagFilter(tag, button));
            // Insert before the "Clear Filter" button
            tagFilterContainer.insertBefore(button, clearTagFilterButton);
        });

        // Add click listener for the clear button
        clearTagFilterButton.addEventListener('click', clearAllTagFilters);
    }

    /**
     * Toggles the selection state of a tag filter button.
     * @param {string} tag - The tag associated with the button.
     * @param {HTMLElement} buttonElement - The button element that was clicked.
     */
    function toggleTagFilter(tag, buttonElement) {
        if (selectedTags.has(tag)) {
            // Tag is currently selected, deselect it
            selectedTags.delete(tag);
            buttonElement.classList.remove('active');
            // Reset background based on tag type
            if (tag === 'Hot 100') {
                buttonElement.classList.add('bg-blue-100', 'text-blue-800');
                buttonElement.classList.remove('bg-blue-600', 'text-white');
            } else {
                buttonElement.classList.add('bg-green-100', 'text-green-800');
                buttonElement.classList.remove('bg-green-600', 'text-white');
            }
        } else {
            // Tag is not selected, select it
            selectedTags.add(tag);
            buttonElement.classList.add('active');
            // Set active background based on tag type
            if (tag === 'Hot 100') {
                buttonElement.classList.remove('bg-blue-100', 'text-blue-800');
                buttonElement.classList.add('bg-blue-600', 'text-white');
            } else {
                buttonElement.classList.remove('bg-green-100', 'text-green-800');
                buttonElement.classList.add('bg-green-600', 'text-white');
            }
        }

        // Show/hide clear button based on whether any tags are selected
        clearTagFilterButton.classList.toggle('hidden', selectedTags.size === 0);

        renderTable(); // Re-render the table with updated filters
    }

    /**
     * Clears all selected tag filters.
     */
    function clearAllTagFilters() {
        selectedTags.clear(); // Clear the set of selected tags
        // Deactivate all tag buttons
        const allTagButtons = tagFilterContainer.querySelectorAll('.tag-filter-button');
        allTagButtons.forEach(button => {
            button.classList.remove('active');
            const tag = button.dataset.tag;
            // Reset background based on tag type
            if (tag === 'Hot 100') {
                button.classList.add('bg-blue-100', 'text-blue-800');
                button.classList.remove('bg-blue-600', 'text-white');
            } else {
                button.classList.add('bg-green-100', 'text-green-800');
                button.classList.remove('bg-green-600', 'text-white');
            }
        });
        clearTagFilterButton.classList.add('hidden'); // Hide the clear button
        renderTable(); // Re-render the table
    }


    /**
     * Updates the sort icon (▲/▼) in the table header based on the current sort direction.
     */
    function updateSortIcon() {
        if (currentSort === 'asc') {
            sortIcon.textContent = '▲'; // Up arrow for ascending
        } else {
            sortIcon.textContent = '▼'; // Down arrow for descending
        }
        sortIcon.classList.remove('text-gray-400');
        sortIcon.classList.add('text-indigo-600'); // Highlight active sort icon
    }

    /**
     * Adds copy functionality to all code blocks.
     */
    function addCopyButtons() {
        const codeBlocks = tableBody.querySelectorAll('pre[class*="language-"]');
        codeBlocks.forEach(block => {
            // Prevent adding multiple buttons if re-rendered
            if (block.querySelector('.copy-button')) {
                return;
            }

            const button = document.createElement('button');
            button.textContent = '复制';
            button.classList.add('copy-button');

            button.addEventListener('click', () => {
                const code = block.querySelector('code').innerText;
                navigator.clipboard.writeText(code).then(() => {
                    button.textContent = '已复制!';
                    button.classList.add('copied');
                    setTimeout(() => {
                        button.textContent = '复制';
                        button.classList.remove('copied');
                    }, 2000); // Reset after 2 seconds
                }).catch(err => {
                    console.error('Failed to copy code: ', err);
                    button.textContent = '失败';
                    setTimeout(() => {
                        button.textContent = '复制';
                    }, 2000);
                });
            });

            block.appendChild(button);
        });
    }


    /**
     * Renders the table content based on current filters and sort order.
     */
    function renderTable() {
        // Clear previous table content, keeping the 'no results' row template
        tableBody.innerHTML = '';
        tableBody.appendChild(noResultsRow); // Keep the template row

        // 1. Filter by Search Term
        let filteredData = problemsData.filter(p => {
            const searchTerm = currentSearchTerm.toLowerCase().trim();
            if (!searchTerm) return true; // No search term, include all
            // Check if ID or title includes the search term
            return String(p.id).includes(searchTerm) || p.title.toLowerCase().includes(searchTerm);
        });

        // 2. Filter by Selected Tags (Multiple)
        if (selectedTags.size > 0) {
            filteredData = filteredData.filter(p => {
                // Check if the problem's tags contain ALL selected tags
                for (const selectedTag of selectedTags) {
                    if (!p.tags.includes(selectedTag)) {
                        return false; // Problem doesn't have one of the selected tags
                    }
                }
                return true; // Problem has all selected tags
            });
        }

        // 3. Sort based on currentSort state
        filteredData.sort((a, b) => {
            return currentSort === 'asc' ? a.id - b.id : b.id - a.id;
        });

        // 4. Render Rows or show 'no results' message
        if (filteredData.length === 0) {
            noResultsRow.classList.remove('hidden'); // Show 'no results' row
        } else {
            noResultsRow.classList.add('hidden'); // Hide 'no results' row
            filteredData.forEach(problem => {
                const row = tableBody.insertRow();
                row.classList.add('hover:bg-gray-50'); // Add hover effect

                // Generate tag spans with specific colors
                const tagSpans = problem.tags.map(tag => {
                    const tagClass = tag === 'Hot 100' ? 'tag-hot100 bg-blue-100 text-blue-800' : 'tag-default bg-green-100 text-green-800';
                    return `<span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${tagClass}">${tag}</span>`;
                }).join(' ');


                // Populate row cells with problem data
                // Use template literals (backticks) for easier HTML embedding
                row.innerHTML = `
          <td class="px-4 py-3 align-top whitespace-nowrap text-sm font-medium text-gray-900">${problem.id}</td>
          <td class="px-4 py-3 align-top text-sm text-gray-700">
            <a href="${problem.url}" target="_blank" class="text-indigo-600 hover:text-indigo-800 hover:underline">${problem.title}</a>
          </td>
          <td class="px-4 py-3 align-top text-sm text-gray-500">
            <div class="flex flex-wrap gap-1">
              ${tagSpans}
            </div>
          </td>
          <td class="px-4 py-3 align-top text-sm text-gray-600 solution-summary-col" style="word-wrap: break-word; white-space: normal;">${problem.summary.replace(/\n/g, '<br>')}</td>
          <td class="px-4 py-3 align-top text-sm text-gray-900 code-col">
            <details>
              <summary>显示/隐藏代码</summary>
              <pre class="language-java rounded-md"><code>${escapeHtml(problem.code)}</code></pre>
            </details>
          </td>
        `;
                // Ensure all cells are vertically aligned to the top
                Array.from(row.cells).forEach(cell => cell.classList.add('align-top'));
            });
        }
        // Apply syntax highlighting to the newly added code blocks
        Prism.highlightAllUnder(tableBody);
        // Add copy buttons to the new code blocks
        addCopyButtons();
    }

    /**
     * Escapes HTML special characters to prevent XSS and rendering issues.
     * @param {string} unsafe - The potentially unsafe string.
     * @returns {string} - The escaped string.
     */
    function escapeHtml(unsafe) {
        // Ensure input is a string before attempting to replace
        if (typeof unsafe !== 'string') {
            console.warn("escapeHtml called with non-string value:", unsafe);
            return ''; // Return empty string or handle appropriately based on context
        }
        return unsafe
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }

    // --- Event Listeners ---

    // Listen for input in the search box
    searchInput.addEventListener('input', (e) => {
        currentSearchTerm = e.target.value; // Update search term state
        renderTable(); // Re-render table
    });

    // Listen for clicks on the sortable table header
    sortHeader.addEventListener('click', () => {
        // Toggle sort direction
        currentSort = (currentSort === 'asc') ? 'desc' : 'asc';
        updateSortIcon(); // Update the arrow icon
        renderTable(); // Re-render table with new sort order
    });


    // --- Initial Setup ---
    // Run when the DOM is fully loaded
    document.addEventListener('DOMContentLoaded', () => {
        // Add Hot 100 tags dynamically before setting up filters and rendering
        problemsData.forEach(problem => {
            if (hot100Titles.has(problem.title)) {
                if (!problem.tags.includes("Hot 100")) {
                    problem.tags.push("Hot 100");
                }
            } else {
                const index = problem.tags.indexOf("Hot 100");
                if (index > -1) {
                    problem.tags.splice(index, 1);
                }
            }
        });

        setupTagFilters(); // Create tag filter buttons based on updated data
        updateSortIcon(); // Set the initial sort icon
        renderTable(); // Perform the initial render of the table
    });

</script>

</body>
</html>
