<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LeetCode 题解 Cheatsheet</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Basic body styling */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Light gray background */
        }

        /* Styling for code blocks */
        pre[class*="language-"] {
            max-height: 300px; /* Limit height */
            overflow: auto; /* Enable scrolling */
            border-radius: 0.375rem; /* Rounded corners */
            scrollbar-width: thin; /* Thin scrollbar for Firefox */
            scrollbar-color: #6b7280 #e5e7eb; /* Scrollbar colors for Firefox */
            margin-top: 0.5rem;
            position: relative; /* Needed for copy button positioning */
            padding-top: 2.5rem; /* Space for the copy button */
        }

        /* Webkit scrollbar styling */
        pre[class*="language-"]::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        pre[class*="language-"]::-webkit-scrollbar-track {
            background: #e5e7eb;
            border-radius: 0.375rem;
        }

        pre[class*="language-"]::-webkit-scrollbar-thumb {
            background-color: #6b7280;
            border-radius: 0.375rem;
            border: 2px solid #e5e7eb;
        }

        /* Table layout */
        table {
            table-layout: fixed;
            width: 100%;
        }

        /* Styling for inline code in solution summary */
        .solution-summary-col code {
            background-color: #fce7f3; /* Lighter pink */
            padding: 0.1em 0.4em;
            border-radius: 0.25rem;
            font-size: 0.9em;
            font-family: monospace;
            color: #be185d; /* Pink-700 */
        }

        /* Styling for bold text in solution summary */
        .solution-summary-col strong, .solution-summary-col b {
            font-weight: 600; /* Make text bold */
            color: #1f2937; /* Slightly darker text for emphasis */
        }

        /* Styling for collapsible code details */
        details > summary {
            cursor: pointer;
            list-style: none; /* Remove default marker */
            padding: 4px 8px;
            background-color: #f9fafb; /* Very light gray */
            border: 1px solid #e5e7eb; /* Light border */
            border-radius: 0.375rem;
            display: inline-block;
            font-size: 0.8rem;
            color: #374151; /* Dark gray text */
            transition: background-color 0.2s ease;
        }

        details > summary:hover {
            background-color: #f3f4f6; /* Slightly darker on hover */
        }

        details > summary::-webkit-details-marker {
            display: none; /* Hide default marker in Webkit */
        }

        /* Custom marker for details */
        details > summary::before {
            content: '▶ '; /* Right-pointing triangle */
            font-size: 0.7em;
            margin-right: 4px;
        }

        details[open] > summary::before {
            content: '▼ '; /* Down-pointing triangle when open */
        }

        /* Styling for clickable sort header */
        #sortHeader {
            cursor: pointer;
            user-select: none; /* Prevent text selection */
        }

        #sortHeader:hover {
            background-color: #e5e7eb; /* Slightly darker gray on hover */
        }

        #sortIcon {
            display: inline-block;
            width: 1em; /* Ensure space for icon */
            text-align: center;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            th, td {
                padding: 8px 4px; /* Reduce padding on smaller screens */
                font-size: 0.875rem; /* Slightly smaller font */
            }

            pre[class*="language-"] {
                max-height: 200px; /* Smaller max height for code blocks */
            }

            /* Stack controls vertically on small screens */
            .controls {
                grid-template-columns: 1fr;
            }

            /* Ensure tag buttons wrap nicely */
            #tagFilterContainer {
                justify-content: flex-start;
            }
        }

        /* Tag filter button styling */
        .tag-filter-button {
            transition: all 0.2s ease-in-out;
            border: 1px solid transparent; /* Base border */
            cursor: pointer;
        }

        .tag-filter-button.active {
            font-weight: 600;
            /* Active state uses ring for better visibility */
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5); /* Blue ring, adjust color as needed */
        }

        .tag-filter-button:not(.active):hover {
            opacity: 0.85; /* Slightly more noticeable hover */
            border-color: #9ca3af; /* Gray border on hover */
        }

        /* Specific styling for tags (background/text color) */
        .tag-default {
            background-color: #dcfce7; /* Light green */
            color: #166534; /* Dark green */
            border-color: #a7f3d0; /* Slightly darker green border */
        }

        .tag-hot100 {
            background-color: #dbeafe; /* Light blue */
            color: #1e40af; /* Dark blue */
            border-color: #bfdbfe; /* Slightly darker blue border */
        }

        /* Style for active state (override base colors) */
        .tag-filter-button.active.tag-default {
            background-color: #16a34a; /* Darker Green */
            color: white;
            border-color: #16a34a;
            box-shadow: 0 0 0 2px rgba(22, 163, 74, 0.5); /* Green ring */
        }

        .tag-filter-button.active.tag-hot100 {
            background-color: #2563eb; /* Darker Blue */
            color: white;
            border-color: #2563eb;
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.5); /* Blue ring */
        }

        /* Copy button styling */
        .copy-button {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background-color: #4b5563; /* Gray-700 */
            color: white;
            border: none;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s ease;
            z-index: 10; /* Ensure button is clickable */
        }

        pre[class*="language-"]:hover .copy-button {
            opacity: 1;
        }

        .copy-button:hover {
            background-color: #374151; /* Gray-800 */
        }

        .copy-button.copied {
            background-color: #10b981; /* Emerald-500 */
        }
    </style>
</head>
<body class="antialiased text-gray-800 p-4 md:p-8">

<div class="container mx-auto bg-white p-6 rounded-lg shadow-lg">
    <h1 class="text-2xl md:text-3xl font-bold mb-6 text-center text-gray-700">LeetCode 题解 Cheatsheet</h1>

    <div class="controls mb-6 grid grid-cols-1 md:grid-cols-2 gap-4 items-end">
        <div>
            <label for="searchInput" class="block text-sm font-medium text-gray-600 mb-1">搜索 (题号或标题):</label>
            <input type="text" id="searchInput" placeholder="例如: 1 或 两数之和"
                   class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
        </div>

        <div class="md:col-span-2">
            <label class="block text-sm font-medium text-gray-600 mb-2">按标签筛选 (可多选):</label>
            <div id="tagFilterContainer" class="flex flex-wrap gap-2">
                <button id="clearTagFilter"
                        class="px-3 py-1 bg-gray-500 text-white text-xs font-medium rounded-full hover:bg-gray-600 transition duration-150 ease-in-out hidden">
                    清除所有筛选
                </button>
            </div>
        </div>
    </div>

    <div class="overflow-x-auto">
        <table id="problemsTable" class="min-w-full divide-y divide-gray-200 border border-gray-200 rounded-lg">
            <thead class="bg-gray-50">
            <tr>
                <th scope="col" id="sortHeader"
                    class="w-1/12 px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider transition-colors duration-150 ease-in-out">
                    题号 <span id="sortIcon" class="text-gray-400"></span>
                </th>
                <th scope="col"
                    class="w-2/12 px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">标题
                </th>
                <th scope="col"
                    class="w-2/12 px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">标签
                </th>
                <th scope="col"
                    class="w-3/12 px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider solution-summary-col">
                    解题思路
                </th>
                <th scope="col"
                    class="w-4/12 px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider code-col">
                    Java 代码
                </th>
            </tr>
            </thead>
            <tbody class="bg-white divide-y divide-gray-200">
            <tr id="noResultsRow" class="hidden">
                <td colspan="5" class="text-center py-4 text-gray-500">未找到匹配的题目。</td>
            </tr>
            </tbody>
        </table>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>

<script>
    // --- Data ---
    const hot100Titles = new Set([
        "两数之和", "字母异位词分组", "最长连续序列", "移动零", "盛最多水的容器",
        "三数之和", "接雨水", "无重复字符的最长子串", "找到字符串中所有字母异位词",
        "和为 K 的子数组", "滑动窗口最大值", "最小覆盖子串", "最大子数组和",
        "合并区间", "轮转数组", "除自身以外数组的乘积", "缺失的第一个正数",
        "矩阵置零", "螺旋矩阵", "旋转图像", "搜索二维矩阵 II", "相交链表",
        "反转链表", "回文链表", "环形链表", "环形链表 II", "合并两个有序链表",
        "两数相加", "删除链表的倒数第 N 个结点", "两两交换链表中的节点",
        "K 个一组翻转链表", "随机链表的复制", "排序链表", "合并 K 个升序链表",
        "LRU 缓存", "二叉树的中序遍历", "二叉树的最大深度", "翻转二叉树",
        "对称二叉树", "二叉树的直径", "二叉树的层序遍历", "将有序数组转换为二叉搜索树",
        "验证二叉搜索树", "二叉搜索树中第 K 小的元素", "二叉树的右视图",
        "二叉树展开为链表", "从前序与中序遍历序列构造二叉树", "路径总和 III",
        "二叉树的最近公共祖先", "二叉树中的最大路径和", "岛屿数量", "腐烂的橘子",
        "课程表", "实现 Trie (前缀树)", "全排列", "子集", "电话号码的字母组合",
        "组合总和", "括号生成", "单词搜索", "分割回文串", "N 皇后",
        "搜索插入位置", "搜索二维矩阵", "在排序数组中查找元素的第一个和最后一个位置",
        "搜索旋转排序数组", "寻找旋转排序数组中的最小值", "寻找两个正序数组的中位数",
        "有效的括号", "最小栈", "字符串解码", "每日温度", "柱状图中最大的矩形",
        "数组中的第K个最大元素", "前 K 个高频元素", "数据流的中位数",
        "买卖股票的最佳时机", "跳跃游戏", "跳跃游戏 II", "划分字母区间",
        "爬楼梯", "杨辉三角", "打家劫舍", "完全平方数", "零钱兑换", "单词拆分",
        "最长递增子序列", "乘积最大子数组", "分割等和子集", "最长有效括号",
        "不同路径", "最小路径和", "最长回文子串", "最长公共子序列", "编辑距离",
        "只出现一次的数字", "多数元素", "颜色分类", "下一个排列", "寻找重复数"
    ]);

    const problemsData = [
        {
            id: 1,
            title: "两数之和",
            url: "https://leetcode.cn/problems/two-sum/",
            tags: ["数组", "哈希表"],
            summary: "利用哈希表 (<code>HashMap</code>) 优化查找。遍历数组 <code>nums</code>，对每个元素 <code>nums[i]</code>，计算目标差值 <code>complement = target - nums[i]</code>。检查 <code>complement</code> 是否已存在于哈希表中。若存在，则返回 <code>complement</code> 的索引和当前索引 <code>i</code>。若不存在，将当前元素 <code>nums[i]</code> 及其索引 <code>i</code> 存入哈希表。时间复杂度 O(n)。",
            code: `import java.util.HashMap;
import java.util.Map;

class Solution {
    /**
     * Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
     * You may assume that each input would have exactly one solution, and you may not use the same element twice.
     * You can return the answer in any order.
     *
     * @param nums Integer array
     * @param target Target sum
     * @return Array containing the indices of the two numbers
     */
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            // Check if the complement exists in the map
            if (map.containsKey(complement)) {
                // If found, return the indices
                return new int[] { map.get(complement), i };
            }
            // Put the current number and its index into the map
            map.put(nums[i], i);
        }
        // According to the problem statement, a solution always exists, so this should not be reached.
        throw new IllegalArgumentException("No two sum solution");
    }
}`
        },
        {
            id: 2,
            title: "两数相加",
            url: "https://leetcode.cn/problems/add-two-numbers/",
            tags: ["递归", "链表", "数学"],
            summary: "模拟手动加法过程。使用哑节点 <code>dummyHead</code> 简化头节点处理。同时遍历链表 <code>l1</code> 和 <code>l2</code>，逐位相加，记录进位 <code>carry</code>。将每位的和 (<code>sum % 10</code>) 创建为新节点，连接到结果链表。若最后仍有进位，需添加额外节点。返回 <code>dummyHead.next</code>。",
            code: `/**
 * Definition for singly-linked list.
 * Assume ListNode class is defined elsewhere or provided by LeetCode environment.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    /**
     * You are given two non-empty linked lists representing two non-negative integers.
     * The digits are stored in reverse order, and each of their nodes contains a single digit.
     * Add the two numbers and return the sum as a linked list.
     *
     * @param l1 The first linked list
     * @param l2 The second linked list
     * @return The head of the linked list representing the sum
     */
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode(0); // Dummy node to simplify head handling
        ListNode current = dummyHead;
        int carry = 0; // Carry-over
        // Iterate through both lists until both are null AND carry is 0
        while (l1 != null || l2 != null || carry != 0) { // Added carry check
            int x = (l1 != null) ? l1.val : 0;
            int y = (l2 != null) ? l2.val : 0;
            int sum = carry + x + y;
            carry = sum / 10; // Calculate new carry

            // Create a new node for the current digit sum (modulo 10)
            current.next = new ListNode(sum % 10);
            current = current.next;

            // Move to the next nodes
            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }
        // The final carry check is now part of the while loop condition
        // Return the next node of the dummy head, which is the actual head of the result list
        return dummyHead.next;
    }
}`
        },
        {
            id: 3,
            title: "无重复字符的最长子串",
            url: "https://leetcode.cn/problems/longest-substring-without-repeating-characters/",
            tags: ["哈希表", "字符串", "滑动窗口"],
            summary: "使用滑动窗口和哈希表 (<code>HashMap<Character, Integer></code>) 记录字符最新索引。维护左右指针 <code>left</code> 和 <code>right</code>。移动 <code>right</code> 扩展窗口，将字符和索引存入哈希表。若遇到重复字符 <code>s.charAt(right)</code> 且其索引 <code>map.get(currentChar) >= left</code>，则将 <code>left</code> 移动到重复字符的下一个位置。每次移动 <code>right</code> 后，更新最大长度 <code>maxLength = Math.max(maxLength, right - left + 1)</code>。返回 <code>maxLength</code>。",
            code: `import java.util.HashMap;
import java.util.Map;

class Solution {
    /**
     * Given a string s, find the length of the longest substring without repeating characters.
     *
     * @param s Input string
     * @return Length of the longest substring without repeating characters
     */
    public int lengthOfLongestSubstring(String s) {
        int n = s.length();
        if (n == 0) {
            return 0;
        }
        // Use HashMap to store characters and their latest indices
        Map<Character, Integer> map = new HashMap<>();
        int maxLength = 0;
        int left = 0; // Left boundary of the sliding window

        for (int right = 0; right < n; right++) {
            char currentChar = s.charAt(right);
            // If the current character is already in the window (i.e., in the map and its index >= left)
            if (map.containsKey(currentChar) && map.get(currentChar) >= left) {
                // Move the left boundary to the position after the repeated character
                left = map.get(currentChar) + 1;
            }
            // Update the latest index of the current character
            map.put(currentChar, right);
            // Calculate the current window length and update the maximum length
            maxLength = Math.max(maxLength, right - left + 1);
        }
        return maxLength;
    }
}`
        },
        {
            id: 4,
            title: "寻找两个正序数组的中位数",
            url: "https://leetcode.cn/problems/median-of-two-sorted-arrays/",
            tags: ["数组", "二分查找", "分治"],
            summary: "要求 O(log(min(m,n))) 复杂度。核心是在较短数组（设为 <code>nums1</code>）上进行二分查找，寻找分割点 <code>i</code>，对应 <code>nums2</code> 的分割点为 <code>j = (m+n+1)/2 - i</code>。目标是找到满足 <code>nums1[i-1] <= nums2[j]</code> 且 <code>nums2[j-1] <= nums1[i]</code> 的 <code>i</code>。根据 <code>nums1[i-1]</code> 和 <code>nums2[j]</code> 的大小关系调整二分查找范围。找到合适的 <code>i</code> 后，根据总长度奇偶性计算中位数：奇数时为 <code>max(nums1[i-1], nums2[j-1])</code>，偶数时为 <code>(max(nums1[i-1], nums2[j-1]) + min(nums1[i], nums2[j])) / 2.0</code>。注意处理边界情况（分割点在数组端点）。",
            code: `class Solution {
    /**
     * Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.
     * The overall run time complexity should be O(log (m+n)).
     *
     * @param nums1 The first sorted array
     * @param nums2 The second sorted array
     * @return The median of the two sorted arrays
     */
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int m = nums1.length;
        int n = nums2.length;
        // Ensure nums1 is the shorter array to optimize binary search
        if (m > n) {
            return findMedianSortedArrays(nums2, nums1); // Swap arrays
        }

        int totalLeft = (m + n + 1) / 2; // Total number of elements desired in the combined left half
        int low = 0; // Binary search range for partition index i in nums1
        int high = m;

        while (low <= high) { // Use standard binary search condition
            int i = low + (high - low) / 2; // Partition index for nums1
            int j = totalLeft - i;      // Corresponding partition index for nums2

            // Get the four boundary elements, handle edge cases with MIN/MAX_VALUE
            int nums1LeftMax = (i == 0) ? Integer.MIN_VALUE : nums1[i - 1];
            int nums1RightMin = (i == m) ? Integer.MAX_VALUE : nums1[i];
            int nums2LeftMax = (j == 0) ? Integer.MIN_VALUE : nums2[j - 1];
            int nums2RightMin = (j == n) ? Integer.MAX_VALUE : nums2[j];

            // Check if the partition is correct
            if (nums1LeftMax <= nums2RightMin && nums2LeftMax <= nums1RightMin) {
                // Partition is correct, calculate median
                if ((m + n) % 2 == 1) { // Odd total length
                    return Math.max(nums1LeftMax, nums2LeftMax);
                } else { // Even total length
                    return (double) (Math.max(nums1LeftMax, nums2LeftMax) + Math.min(nums1RightMin, nums2RightMin)) / 2.0;
                }
            } else if (nums1LeftMax > nums2RightMin) {
                // Partition i in nums1 is too large, decrease high
                high = i - 1;
            } else { // nums2LeftMax > nums1RightMin
                // Partition i in nums1 is too small, increase low
                low = i + 1;
            }
        }
        // Should not be reached if input arrays are sorted
        throw new IllegalArgumentException("Input arrays are not sorted or invalid.");
    }
}`
        },
        {
            id: 5,
            title: "最长回文子串",
            url: "https://leetcode.cn/problems/longest-palindromic-substring/",
            tags: ["字符串", "动态规划"],
            summary: "方法：<strong>中心扩展法</strong>。遍历字符串 <code>s</code>，以每个索引 <code>i</code> 以及 <code>i</code> 和 <code>i+1</code> 之间作为中心点。调用 <code>expandAroundCenter(s, left, right)</code> 函数从中心向两边扩展，查找并返回以该中心为基准的最长回文串长度 <code>len</code>。记录并更新全局最长回文串的起止索引 <code>start</code> 和 <code>end</code>。最后返回 <code>s.substring(start, end + 1)</code>。<br><code>expandAroundCenter</code> 函数: 从给定的 <code>left</code>, <code>right</code> 中心向两边扩展，直到边界或字符不匹配，返回找到的回文串长度。",
            code: `class Solution {
    /**
     * Given a string s, return the longest palindromic substring in s.
     * A string is called a palindrome string if the reverse of that string is the same as the original string.
     *
     * @param s Input string
     * @return The longest palindromic substring
     */
    public String longestPalindrome(String s) {
        if (s == null || s.length() < 1) {
            return "";
        }
        int start = 0; // Start index of the longest palindrome found so far
        int end = 0;   // End index of the longest palindrome found so far

        for (int i = 0; i < s.length(); i++) {
            // Handle odd length palindromes (center is a single character i)
            int len1 = expandAroundCenter(s, i, i);
            // Handle even length palindromes (center is between characters i and i+1)
            int len2 = expandAroundCenter(s, i, i + 1);
            int len = Math.max(len1, len2);

            // If a longer palindrome is found, update start and end indices
            // Current palindrome length is end - start + 1
            if (len > end - start + 1) {
                // Calculate new start and end based on center i and length len
                start = i - (len - 1) / 2;
                end = i + len / 2;
            }
        }
        // Extract the substring based on start and end indices (inclusive)
        return s.substring(start, end + 1);
    }

    /**
     * Helper function to expand around the center and find the length of the longest palindrome.
     *
     * @param s     Input string
     * @param left  Left boundary (or center point)
     * @param right Right boundary (or center point)
     * @return The length of the longest palindrome centered at left and right
     */
    private int expandAroundCenter(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;  // Expand left
            right++; // Expand right
        }
        // The length of the palindrome is R - L - 1 after the loop terminates
        // Example "aba": L=-1, R=3 -> R-L-1 = 3 - (-1) - 1 = 3
        // Example "abba": L=-1, R=4 -> R-L-1 = 4 - (-1) - 1 = 4
        return right - left - 1;
    }
}`
        },
        {
            id: 7,
            title: "整数反转",
            url: "https://leetcode.cn/problems/reverse-integer/",
            tags: ["数学"],
            summary: "循环处理整数 <code>x</code> 直到其为 0。每次取末位 <code>digit = x % 10</code>，移除末位 <code>x /= 10</code>。在更新反转结果 <code>reversed = reversed * 10 + digit</code> <strong>之前</strong>，必须进行<strong>溢出检查</strong>：检查 <code>reversed</code> 是否大于 <code>Integer.MAX_VALUE / 10</code> 或小于 <code>Integer.MIN_VALUE / 10</code>，以及在等于边界值时 <code>digit</code> 是否会导致溢出。若溢出，返回 0。否则，更新 <code>reversed</code>。循环结束后返回 <code>reversed</code>。",
            code: `class Solution {
    /**
     * Given a signed 32-bit integer x, return x with its digits reversed.
     * If reversing x causes the value to go outside the signed 32-bit integer range [-2^31, 2^31 - 1], then return 0.
     * Assume the environment does not allow you to store 64-bit integers (signed or unsigned).
     *
     * @param x Input integer
     * @return Reversed integer, or 0 if overflow occurs
     */
    public int reverse(int x) {
        int reversed = 0;
        while (x != 0) {
            int digit = x % 10; // Get the last digit
            x /= 10;         // Remove the last digit

            // Check for positive overflow BEFORE multiplication/addition
            if (reversed > Integer.MAX_VALUE / 10 || (reversed == Integer.MAX_VALUE / 10 && digit > 7)) {
                return 0;
            }
            // Check for negative overflow BEFORE multiplication/addition
            if (reversed < Integer.MIN_VALUE / 10 || (reversed == Integer.MIN_VALUE / 10 && digit < -8)) {
                return 0;
            }

            reversed = reversed * 10 + digit; // Append the digit
        }
        return reversed;
    }
}`
        },
        {
            id: 8,
            title: "字符串转换整数 (atoi)",
            url: "https://leetcode.cn/problems/string-to-integer-atoi/",
            tags: ["字符串"],
            summary: "按规则模拟转换：跳过前导空格；检查可选的 '+' 或 '-' 号，记录符号 <code>sign</code>；循环读取数字字符，累加到 <code>result</code> (使用 <code>long</code> 类型)。在累加<strong>之前</strong>检查是否会超出 <code>Integer</code> 范围，若超出则提前返回边界值；遇到非数字字符或结束时停止；返回 <code>(int)(result * sign)</code>，并做最终范围检查。",
            code: `class Solution {
    /**
     * Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).
     *
     * @param s Input string
     * @return The converted integer
     */
    public int myAtoi(String s) {
        int index = 0;
        int n = s.length();

        // 1. Discard leading whitespace
        while (index < n && s.charAt(index) == ' ') {
            index++;
        }

        // 2. Check for optional sign
        int sign = 1;
        if (index < n && (s.charAt(index) == '+' || s.charAt(index) == '-')) {
            sign = (s.charAt(index) == '-') ? -1 : 1;
            index++;
        }

        long result = 0; // Use long to prevent intermediate overflow

        // 3. Read digits and handle overflow
        while (index < n && Character.isDigit(s.charAt(index))) {
            int digit = s.charAt(index) - '0';

            // Check for overflow BEFORE updating result
            // Check if result * 10 + digit will exceed MAX_VALUE for positive numbers
            if (sign == 1 && result > (Integer.MAX_VALUE - digit) / 10) {
                 return Integer.MAX_VALUE;
            }
             // Check if result * 10 + digit will exceed MIN_VALUE for negative numbers
             // Careful with MIN_VALUE which is -2^31
             if (sign == -1 && -result < (Integer.MIN_VALUE + digit) / 10 ) { // Check negative overflow
                 return Integer.MIN_VALUE;
             }


            result = result * 10 + digit;
            index++;
        }

        // 4. Apply sign
        result *= sign;

        // 5. Final clamp to Integer range
        if (result > Integer.MAX_VALUE) {
            return Integer.MAX_VALUE;
        }
        if (result < Integer.MIN_VALUE) {
            return Integer.MIN_VALUE;
        }

        return (int) result;
    }
}`
        },
        {
            id: 9,
            title: "回文数",
            url: "https://leetcode.cn/problems/palindrome-number/",
            tags: ["数学"],
            summary: "判断整数 <code>x</code> 是否回文。方法1：转为字符串判断。方法2：数学方法。排除特殊情况（负数、末尾为0的非零数）。使用 <code>while (x > revertedNumber)</code> 循环反转 <code>x</code> 的后半部分到 <code>revertedNumber</code>。最后比较：若长度为偶数，判断 <code>x == revertedNumber</code>；若长度为奇数，判断 <code>x == revertedNumber / 10</code>。",
            code: `class Solution {
    /**
     * Given an integer x, return true if x is a palindrome integer.
     * An integer is a palindrome when it reads the same backward as forward.
     * For example, 121 is palindrome while 123 is not.
     *
     * @param x Input integer
     * @return True if x is a palindrome, false otherwise
     */
    public boolean isPalindrome(int x) {
        // Special cases:
        // Negative numbers are not palindromes.
        // Also, if the last digit of the number is 0, in order to be a palindrome,
        // the first digit of the number also needs to be 0. Only 0 satisfies this property.
        if (x < 0 || (x % 10 == 0 && x != 0)) {
            return false;
        }

        int revertedNumber = 0;
        // Reverse the second half of the number
        while (x > revertedNumber) {
            revertedNumber = revertedNumber * 10 + x % 10;
            x /= 10;
        }

        // When the length is an odd number, we can get rid of the middle digit by revertedNumber/10
        // For example when the input is 12321, at the end of the while loop we get x = 12, revertedNumber = 123,
        // since the middle digit doesn't matter in palidrome(it will always equal to itself), we can simply get rid of it.
        // When the length is an even number, x == revertedNumber
        // For example when the input is 1221, at the end of the while loop we get x = 12, revertedNumber = 12
        return x == revertedNumber || x == revertedNumber / 10;
    }
}`
        },
        {
            id: 10,
            title: "正则表达式匹配",
            url: "https://leetcode.cn/problems/regular-expression-matching/",
            tags: ["递归", "字符串", "动态规划"],
            summary: "使用<strong>动态规划</strong>。定义 <code>dp[i][j]</code> 为 <code>s</code> 前 <code>i</code> 字符与 <code>p</code> 前 <code>j</code> 字符是否匹配。初始化 <code>dp[0][0]=true</code> 及处理 <code>p</code> 开头的 <code>*</code>。状态转移：若 <code>p[j-1]</code> 匹配 <code>s[i-1]</code> (或为 <code>.</code>)，则 <code>dp[i][j] = dp[i-1][j-1]</code>；若 <code>p[j-1] == '*'</code>，则 <code>dp[i][j]</code> 可由 <code>*</code> 匹配 0 次 (<code>dp[i][j-2]</code>) 或 <code>*</code> 匹配 1 次或多次 (<code>dp[i-1][j]</code> 且 <code>s[i-1]</code> 匹配 <code>p[j-2]</code>) 得到。返回 <code>dp[m][n]</code>。",
            code: `class Solution {
    /**
     * Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'.
     * '.' Matches any single character.
     * '*' Matches zero or more of the preceding element.
     * The matching should cover the entire input string (not partial).
     *
     * @param s Input string
     * @param p Pattern string
     * @return True if s and p match, false otherwise
     */
    public boolean isMatch(String s, String p) {
        int m = s.length();
        int n = p.length();

        // dp[i][j] represents if the first i characters of s match the first j characters of p
        boolean[][] dp = new boolean[m + 1][n + 1];
        dp[0][0] = true; // Empty string matches empty pattern

        // Handle patterns like a*, a*b*, a*b*c* that can match an empty string
        // Initialize dp[0][j] for patterns matching empty string
        for (int j = 1; j <= n; j++) {
            if (p.charAt(j - 1) == '*') {
                // '*' can match zero preceding elements. Check dp[0][j-2].
                 if (j >= 2) { // Ensure there is a preceding character
                    dp[0][j] = dp[0][j - 2];
                 }
                 // else: '*' at the beginning or after another '*' is invalid or handled by dp[0][j-2] being false
            }
        }

        // Fill the DP table
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                char sChar = s.charAt(i - 1);
                char pChar = p.charAt(j - 1);

                if (pChar == '.' || sChar == pChar) {
                    // Case 1: Current characters match or pattern has '.'
                    dp[i][j] = dp[i - 1][j - 1];
                } else if (pChar == '*') {
                    // Case 2: Pattern has '*'
                    // '*' must have a preceding character p[j-2]
                    if (j >= 2) {
                        // Option A: '*' matches zero occurrences of p[j-2]
                        // Check if s[0..i-1] matches p[0..j-3]
                        boolean matchZero = dp[i][j - 2];

                        // Option B: '*' matches one or more occurrences of p[j-2]
                        // This requires p[j-2] to match s[i-1]
                        boolean matchOneOrMore = false;
                        if (p.charAt(j - 2) == '.' || p.charAt(j - 2) == sChar) {
                            // If they match, '*' can potentially match s[i-1].
                            // The result depends on whether s[0..i-2] matches p[0..j-1] (including the '*')
                            // dp[i-1][j] means the '*' is used to match s[i-1]
                            matchOneOrMore = dp[i - 1][j];
                        }
                        dp[i][j] = matchZero || matchOneOrMore;
                    }
                    // else: '*' at beginning or after another '*', dp[i][j] remains false

                }
                // Case 3: Characters mismatch and pattern is not '*', dp[i][j] remains false (default)
            }
        }

        return dp[m][n]; // Return the result for the full strings
    }
}`
        },
        {
            id: 11,
            title: "盛最多水的容器",
            url: "https://leetcode.cn/problems/container-with-most-water/",
            tags: ["贪心", "数组", "双指针"],
            summary: "使用<strong>双指针</strong>和<strong>贪心</strong>策略。初始化左右指针 <code>left</code>, <code>right</code> 指向数组首尾，最大面积 <code>maxArea = 0</code>。当 <code>left < right</code> 时循环：计算当前高度 <code>h = min(height[left], height[right])</code> 和宽度 <code>width = right - left</code>，更新 <code>maxArea</code>。然后，将指向<strong>较短板</strong>的指针向内移动一步。这是因为移动短板才可能遇到更高的板，从而增大面积。",
            code: `class Solution {
    /**
     * Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai).
     * n vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0).
     * Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.
     * Return the maximum amount of water a container can store.
     * Notice that you may not slant the container.
     *
     * @param height Array representing the heights of the vertical lines
     * @return Maximum amount of water that can be stored
     */
    public int maxArea(int[] height) {
        int maxArea = 0;
        int left = 0; // Left pointer
        int right = height.length - 1; // Right pointer

        while (left < right) {
            // Calculate the width of the current container
            int width = right - left;
            // Calculate the height of the current container (limited by the shorter line)
            int h = Math.min(height[left], height[right]);
            // Calculate the area of the current container and update maxArea
            maxArea = Math.max(maxArea, width * h);

            // Move the pointer pointing to the shorter line inward
            // This is the greedy choice: moving the shorter line's pointer
            // gives a chance to find a taller line, potentially increasing the area.
            // Moving the taller line's pointer will definitely not increase the height,
            // and will decrease the width, thus decreasing the area.
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }
        return maxArea;
    }
}`
        },
        {
            id: 12,
            title: "整数转罗马数字",
            url: "https://leetcode.cn/problems/integer-to-roman/",
            tags: ["哈希表", "数学", "字符串"],
            summary: "采用<strong>贪心</strong>策略。预定义罗马数字符号及其对应的值（包括特殊组合如 <code>CM</code>, <code>CD</code>, <code>XC</code>, <code>XL</code>, <code>IX</code>, <code>IV</code>），按值从大到小存储。遍历这个映射关系，对于每个值 <code>value</code> 和符号 <code>symbol</code>，当输入整数 <code>num >= value</code> 时，将 <code>symbol</code> 追加到结果字符串，并将 <code>num</code> 减去 <code>value</code>，重复此过程直到 <code>num < value</code>。继续处理下一个更小的值。",
            code: `import java.util.LinkedHashMap;
import java.util.Map;

class Solution {
    /**
     * Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
     * ... (rules omitted) ...
     * Given an integer, convert it to a roman numeral.
     *
     * @param num Input integer (1 <= num <= 3999)
     * @return The corresponding Roman numeral string
     */
    public String intToRoman(int num) {
        // Use LinkedHashMap to maintain insertion order (from largest to smallest value)
        Map<Integer, String> romanMap = new LinkedHashMap<>();
        romanMap.put(1000, "M");
        romanMap.put(900, "CM");
        romanMap.put(500, "D");
        romanMap.put(400, "CD");
        romanMap.put(100, "C");
        romanMap.put(90, "XC");
        romanMap.put(50, "L");
        romanMap.put(40, "XL");
        romanMap.put(10, "X");
        romanMap.put(9, "IX");
        romanMap.put(5, "V");
        romanMap.put(4, "IV");
        romanMap.put(1, "I");

        StringBuilder roman = new StringBuilder();

        // Greedy algorithm: Iterate through the map from largest value to smallest
        for (Map.Entry<Integer, String> entry : romanMap.entrySet()) {
            int value = entry.getKey();
            String symbol = entry.getValue();

            // Append the symbol as many times as possible
            while (num >= value) {
                roman.append(symbol);
                num -= value;
            }

            if (num == 0) {
                break; // Optimization: if num becomes 0, we are done
            }
        }
        return roman.toString();
    }
}`
        },
        {
            id: 13,
            title: "罗马数字转整数",
            url: "https://leetcode.cn/problems/roman-to-integer/",
            tags: ["哈希表", "数学", "字符串"],
            summary: "遍历罗马数字字符串 <code>s</code>。使用哈希表存储每个罗马字符对应的值。对于当前字符 <code>s[i]</code>，检查其后的字符 <code>s[i+1]</code>。如果 <code>s[i]</code> 的值小于 <code>s[i+1]</code> 的值（构成特殊减法规则，如 <code>IV</code>, <code>IX</code>），则从结果中减去 <code>s[i]</code> 的值。否则，将 <code>s[i]</code> 的值加到结果中。",
            code: `import java.util.HashMap;
import java.util.Map;

class Solution {
    /**
     * Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
     * ... (rules omitted) ...
     * Given a roman numeral, convert it to an integer.
     *
     * @param s Roman numeral string (1 <= s.length <= 15, guaranteed to be valid)
     * @return The corresponding integer
     */
    public int romanToInt(String s) {
        Map<Character, Integer> romanMap = new HashMap<>();
        romanMap.put('I', 1);
        romanMap.put('V', 5);
        romanMap.put('X', 10);
        romanMap.put('L', 50);
        romanMap.put('C', 100);
        romanMap.put('D', 500);
        romanMap.put('M', 1000);

        int result = 0;
        int n = s.length();

        for (int i = 0; i < n; i++) {
            int currentValue = romanMap.get(s.charAt(i));

            // Check if the next character forms a special subtraction case
            if (i < n - 1 && currentValue < romanMap.get(s.charAt(i + 1))) {
                result -= currentValue; // Subtract the current value
            } else {
                result += currentValue; // Add the current value
            }
        }
        return result;
    }
}`
        },
        {
            id: 14,
            title: "最长公共前缀",
            url: "https://leetcode.cn/problems/longest-common-prefix/",
            tags: ["字符串"],
            summary: "方法：<strong>纵向扫描</strong>。以第一个字符串 <code>strs[0]</code> 为基准。遍历第一个字符串的每个字符（索引 <code>i</code>）。对于每个字符 <code>c = strs[0].charAt(i)</code>，检查数组中所有其他字符串 <code>strs[j]</code> 的相同位置 <code>i</code> 上的字符。如果遇到任何字符串长度不足 <code>i</code>，或者 <code>strs[j].charAt(i) != c</code>，则说明最长公共前缀是 <code>strs[0]</code> 的前 <code>i</code> 个字符 (<code>strs[0].substring(0, i)</code>)。如果遍历完第一个字符串的所有字符都匹配，则第一个字符串本身就是最长公共前缀。",
            code: `class Solution {
    /**
     * Write a function to find the longest common prefix string amongst an array of strings.
     * If there is no common prefix, return an empty string "".
     *
     * @param strs Array of strings
     * @return The longest common prefix
     */
    public String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0) {
            return "";
        }

        // Use the first string as the reference
        String firstString = strs[0];
        int prefixLength = firstString.length();
        int count = strs.length;

        // Iterate through characters of the first string
        for (int i = 0; i < prefixLength; i++) {
            char c = firstString.charAt(i); // Character to compare

            // Compare this character with the character at the same position in other strings
            for (int j = 1; j < count; j++) {
                // If the other string is shorter than index i, or characters don't match
                if (i == strs[j].length() || strs[j].charAt(i) != c) {
                    // The common prefix ends before index i
                    return firstString.substring(0, i);
                }
            }
        }

        // If the loop completes, the entire first string is the common prefix
        return firstString;
    }
}`
        },
        {
            id: 15,
            title: "三数之和",
            url: "https://leetcode.cn/problems/3sum/",
            tags: ["数组", "双指针", "排序"],
            summary: "先对数组 <code>nums</code> <strong>排序</strong>。遍历数组，固定第一个数 <code>nums[i]</code>。若 <code>nums[i] > 0</code>，后续不可能和为 0，可提前结束。跳过重复的 <code>nums[i]</code>。然后使用<strong>双指针</strong> <code>left = i + 1</code> 和 <code>right = n - 1</code> 在 <code>i</code> 之后查找。令 <code>target = -nums[i]</code>。当 <code>left < right</code> 时：若 <code>nums[left] + nums[right] == target</code>，记录结果，并移动 <code>left</code> 和 <code>right</code> 跳过重复元素；若和小于 <code>target</code>，<code>left++</code>；若和大于 <code>target</code>，<code>right--</code>。",
            code: `import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Solution {
    /**
     * Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
     * Notice that the solution set must not contain duplicate triplets.
     *
     * @param nums Integer array
     * @return A list of all unique triplets that sum to zero
     */
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        if (nums == null || nums.length < 3) {
            return result;
        }

        // 1. Sort the array
        Arrays.sort(nums);
        int n = nums.length;

        // 2. Iterate through the array, fixing the first element nums[i]
        for (int i = 0; i < n - 2; i++) {
            // Optimization: If the current number is positive, the sum cannot be zero
            if (nums[i] > 0) {
                break;
            }
            // Skip duplicate first elements
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }

            // 3. Use two pointers for the remaining part
            int left = i + 1;
            int right = n - 1;
            int target = -nums[i]; // The target sum for the two pointers

            while (left < right) {
                int sum = nums[left] + nums[right];

                if (sum == target) {
                    // Found a triplet
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));

                    // Skip duplicate second and third elements
                    while (left < right && nums[left] == nums[left + 1]) {
                        left++;
                    }
                    while (left < right && nums[right] == nums[right - 1]) {
                        right--;
                    }

                    // Move pointers to the next distinct elements
                    left++;
                    right--;
                } else if (sum < target) {
                    // Sum is too small, move left pointer
                    left++;
                } else {
                    // Sum is too large, move right pointer
                    right--;
                }
            }
        }
        return result;
    }
}`
        },
        {
            id: 17,
            title: "电话号码的字母组合",
            url: "https://leetcode.cn/problems/letter-combinations-of-a-phone-number/",
            tags: ["哈希表", "字符串", "回溯"],
            summary: "使用<strong>回溯</strong>算法生成所有组合。维护一个数字到字母映射的哈希表 <code>phoneMap</code>。定义一个递归函数 <code>backtrack(index, currentCombination)</code>。<code>index</code> 是当前处理的 <code>digits</code> 字符串的索引，<code>currentCombination</code> 是当前构建的组合 (<code>StringBuilder</code>)。递归基：当 <code>index</code> 等于 <code>digits</code> 长度时，将 <code>currentCombination</code> 加入结果列表。递归步骤：获取当前数字 <code>digits[index]</code> 对应的字母串 <code>letters</code>。遍历 <code>letters</code> 中的每个字母 <code>letter</code>，将其追加到 <code>currentCombination</code>，递归调用 <code>backtrack(index + 1, currentCombination)</code>，然后从 <code>currentCombination</code> 中删除该字母（回溯）。",
            code: `import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

class Solution {
    // Mapping from digit to letters
    private Map<Character, String> phoneMap = new HashMap<>() {{
        put('2', "abc");
        put('3', "def");
        put('4', "ghi");
        put('5', "jkl");
        put('6', "mno");
        put('7', "pqrs");
        put('8', "tuv");
        put('9', "wxyz");
    }};

    private List<String> combinations = new ArrayList<>(); // Stores the final combinations
    private StringBuilder currentCombination = new StringBuilder(); // Stores the combination being built

    /**
     * Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.
     * Return the answer in any order.
     *
     * @param digits Input string of digits
     * @return List of all possible letter combinations
     */
    public List<String> letterCombinations(String digits) {
        if (digits == null || digits.length() == 0) {
            return combinations;
        }
        backtrack(digits, 0);
        return combinations;
    }

    /**
     * Backtracking function to generate combinations.
     * @param digits The input digit string
     * @param index The current index in the digits string being processed
     */
    private void backtrack(String digits, int index) {
        // Base case: If the current combination length equals the digits length, add it to the result
        if (index == digits.length()) {
            combinations.add(currentCombination.toString());
            return;
        }

        char digit = digits.charAt(index);
        String letters = phoneMap.get(digit);

        // Iterate through the letters corresponding to the current digit
        for (char letter : letters.toCharArray()) {
            // Make a choice: append the current letter
            currentCombination.append(letter);
            // Recurse for the next digit
            backtrack(digits, index + 1);
            // Undo the choice (backtrack): remove the last appended letter
            currentCombination.deleteCharAt(currentCombination.length() - 1);
        }
    }
}`
        },
        {
            id: 19,
            title: "删除链表的倒数第 N 个结点",
            url: "https://leetcode.cn/problems/remove-nth-node-from-end-of-list/",
            tags: ["链表", "双指针"],
            summary: "使用<strong>快慢指针</strong>。创建哑节点 <code>dummy</code> 指向 <code>head</code>。快指针 <code>fast</code> 先向前移动 <code>n</code> 步。然后，慢指针 <code>slow</code> 从 <code>dummy</code> 开始，与 <code>fast</code> 同时向前移动。当 <code>fast</code> 到达链表末尾 (<code>null</code>) 时，<code>slow</code> 正好指向待删除节点的前一个节点。执行删除操作 <code>slow.next = slow.next.next</code>。返回 <code>dummy.next</code>。",
            code: `/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    /**
     * Given the head of a linked list, remove the nth node from the end of the list and return its head.
     *
     * @param head The head of the linked list
     * @param n    The position from the end of the node to remove
     * @return The head of the modified linked list
     */
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // Create a dummy node to handle edge cases like removing the head
        ListNode dummy = new ListNode(0, head);
        ListNode fast = head;
        ListNode slow = dummy; // slow starts at dummy, pointing before the node to potentially remove

        // Move fast pointer n steps ahead
        for (int i = 0; i < n; i++) {
            if (fast != null) {
                fast = fast.next;
            } else {
                // This case should not happen based on constraints (n <= list size),
                // but good practice to handle.
                return head; // Or throw an exception
            }
        }

        // Move both pointers simultaneously until fast reaches the end
        while (fast != null) {
            fast = fast.next;
            slow = slow.next;
        }

        // slow now points to the node *before* the one to be removed
        // Remove the nth node from the end
        if (slow.next != null) {
            slow.next = slow.next.next;
        }

        // Return the head of the modified list (dummy.next)
        return dummy.next;
    }
}`
        },
        {
            id: 20,
            title: "有效的括号",
            url: "https://leetcode.cn/problems/valid-parentheses/",
            tags: ["栈", "字符串"],
            summary: "使用<strong>栈</strong> (<code>Stack</code>) 和哈希映射 (<code>Map</code>) 存储括号配对关系。遍历字符串 <code>s</code>：遇到左括号 (<code>(</code>, <code>[</code>, <code>{</code>)，将其压入栈。遇到右括号 (<code>)</code>, <code>]</code>, <code>}</code>)，检查栈是否为空，或者栈顶元素是否是当前右括号对应的左括号。若栈为空或不匹配，则字符串无效，返回 <code>false</code>。若匹配，则弹出栈顶元素。遍历结束后，检查栈是否为空。若为空，则字符串有效，返回 <code>true</code>；否则无效，返回 <code>false</code>。",
            code: `import java.util.Stack;
import java.util.Map;
import java.util.HashMap;

class Solution {
    /**
     * Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
     * An input string is valid if:
     * 1. Open brackets must be closed by the same type of brackets.
     * 2. Open brackets must be closed in the correct order.
     * 3. Every close bracket has a corresponding open bracket of the same type.
     *
     * @param s Input string containing brackets
     * @return True if the string is valid, false otherwise
     */
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        // Map to store the matching pairs of brackets
        Map<Character, Character> mapping = new HashMap<>();
        mapping.put(')', '(');
        mapping.put(']', '[');
        mapping.put('}', '{');

        for (char c : s.toCharArray()) {
            // If it's an opening bracket, push onto the stack
            if (mapping.containsValue(c)) { // Check if it's one of '(', '[', '{'
                stack.push(c);
            }
            // If it's a closing bracket
            else if (mapping.containsKey(c)) { // Check if it's one of ')', ']', '}'
                // Check if the stack is empty or the top element doesn't match
                if (stack.isEmpty() || stack.peek() != mapping.get(c)) {
                    return false; // Invalid sequence
                }
                // Matching bracket found, pop from stack
                stack.pop();
            }
            // Ignore other characters if any (though problem says only brackets)
        }

        // After iterating through the string, the stack should be empty for a valid string
        return stack.isEmpty();
    }
}`
        },
        {
            id: 21,
            title: "合并两个有序链表",
            url: "https://leetcode.cn/problems/merge-two-sorted-lists/",
            tags: ["递归", "链表"],
            summary: "方法1：<strong>迭代</strong>。创建哑节点 <code>dummy</code> 和当前指针 <code>current</code>。比较 <code>list1</code> 和 <code>list2</code> 的当前节点值。将值较小的节点连接到 <code>current.next</code>，并移动该链表的指针和 <code>current</code> 指针。当一个链表为空时，将另一个链表的剩余部分连接到 <code>current.next</code>。返回 <code>dummy.next</code>。\n方法2：<strong>递归</strong>。比较 <code>list1</code> 和 <code>list2</code> 的头节点。值较小的节点作为新头节点，其 <code>next</code> 指向对其余部分递归调用的结果。",
            code: `/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    /**
     * Merge two sorted linked lists and return it as a new sorted list.
     * The new list should be made by splicing together the nodes of the first two lists.
     *
     * @param list1 Head of the first sorted linked list
     * @param list2 Head of the second sorted linked list
     * @return Head of the merged sorted linked list
     */
    // Iterative Approach
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        // Create a dummy node to simplify the merging process
        ListNode dummy = new ListNode(-1);
        ListNode current = dummy; // Pointer to the current node in the merged list

        // Pointers to traverse list1 and list2
        ListNode p1 = list1;
        ListNode p2 = list2;

        // Iterate while both lists have nodes
        while (p1 != null && p2 != null) {
            if (p1.val <= p2.val) {
                current.next = p1; // Append the smaller node from list1
                p1 = p1.next;      // Move p1 forward
            } else {
                current.next = p2; // Append the smaller node from list2
                p2 = p2.next;      // Move p2 forward
            }
            current = current.next; // Move the current pointer forward in the merged list
        }

        // Append the remaining nodes from either list1 or list2
        if (p1 != null) {
            current.next = p1;
        } else {
            current.next = p2;
        }

        // Return the head of the merged list (dummy.next)
        return dummy.next;
    }
}`
        },
        {
            id: 22,
            title: "括号生成",
            url: "https://leetcode.cn/problems/generate-parentheses/",
            tags: ["字符串", "动态规划", "回溯"],
            summary: "使用<strong>回溯</strong>算法生成所有有效的括号组合。定义递归函数 <code>backtrack(currentString, openCount, closeCount, n)</code>。参数：<code>currentString</code> 当前构建的字符串，<code>openCount</code> 已用左括号数，<code>closeCount</code> 已用右括号数，<code>n</code> 目标括号对数。递归基：当 <code>currentString</code> 长度达到 <code>2*n</code> 时，将其加入结果列表。递归步骤：如果 <code>openCount < n</code>，可以添加左括号，递归调用 <code>backtrack(..., openCount + 1, ...)</code>，然后回溯。如果 <code>closeCount < openCount</code>，可以添加右括号，递归调用 <code>backtrack(..., closeCount + 1, ...)</code>，然后回溯。",
            code: `import java.util.ArrayList;
import java.util.List;

class Solution {
    private List<String> result = new ArrayList<>(); // Stores the final valid combinations

    /**
     * Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
     *
     * @param n The number of pairs of parentheses
     * @return A list of all valid parenthesis combinations
     */
    public List<String> generateParenthesis(int n) {
        backtrack(new StringBuilder(), 0, 0, n);
        return result;
    }

    /**
     * Backtracking function to generate parentheses.
     * @param current The StringBuilder holding the current combination being built
     * @param open    The count of open parentheses used so far
     * @param close   The count of close parentheses used so far
     * @param max     The target number of pairs (n)
     */
    private void backtrack(StringBuilder current, int open, int close, int max) {
        // Base case: If the length of the current string is 2 * max, we have a complete combination
        if (current.length() == max * 2) {
            result.add(current.toString());
            return;
        }

        // Condition to add an open parenthesis: if the count of open parentheses is less than max
        if (open < max) {
            current.append('('); // Make the choice
            backtrack(current, open + 1, close, max); // Recurse
            current.deleteCharAt(current.length() - 1); // Undo the choice (backtrack)
        }

        // Condition to add a close parenthesis: if the count of close parentheses is less than the count of open parentheses
        if (close < open) {
            current.append(')'); // Make the choice
            backtrack(current, open, close + 1, max); // Recurse
            current.deleteCharAt(current.length() - 1); // Undo the choice (backtrack)
        }
    }
}`
        },
        // Problems 11-20 (corresponding to IDs 12, 13, 14, 15, 17, 19, 20, 21, 22, 23)
        {
            id: 12,
            title: "整数转罗马数字",
            url: "https://leetcode.cn/problems/integer-to-roman/",
            tags: ["哈希表", "数学", "字符串"],
            summary: "采用<strong>贪心</strong>策略。预定义罗马数字符号及其对应值（含特殊组合如 <code>CM</code>, <code>IX</code> 等），按值从大到小存储 (<code>LinkedHashMap</code>)。遍历映射，对每个值 <code>value</code>，尽可能多地将对应符号 <code>symbol</code> 追加到结果，并从输入整数 <code>num</code> 中减去 <code>value</code>。",
            code: `import java.util.LinkedHashMap;
import java.util.Map;

class Solution {
    /**
     * Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
     * ... (rules omitted)...
     * Given an integer, convert it to a roman numeral.
     *
     * @param num Input integer (1 <= num <= 3999)
     * @return The corresponding Roman numeral string
     */
    public String intToRoman(int num) {
        // Use LinkedHashMap to maintain insertion order (from largest to smallest value)
        Map<Integer, String> romanMap = new LinkedHashMap<>();
        romanMap.put(1000, "M");
        romanMap.put(900, "CM");
        romanMap.put(500, "D");
        romanMap.put(400, "CD");
        romanMap.put(100, "C");
        romanMap.put(90, "XC");
        romanMap.put(50, "L");
        romanMap.put(40, "XL");
        romanMap.put(10, "X");
        romanMap.put(9, "IX");
        romanMap.put(5, "V");
        romanMap.put(4, "IV");
        romanMap.put(1, "I");

        StringBuilder roman = new StringBuilder();

        // Greedy algorithm: Iterate through the map from largest value to smallest
        for (Map.Entry<Integer, String> entry : romanMap.entrySet()) {
            int value = entry.getKey();
            String symbol = entry.getValue();

            // Append the symbol as many times as possible
            while (num >= value) {
                roman.append(symbol);
                num -= value;
            }

            if (num == 0) {
                break; // Optimization: if num becomes 0, we are done
            }
        }
        return roman.toString();
    }
}`
        },
        {
            id: 13,
            title: "罗马数字转整数",
            url: "https://leetcode.cn/problems/roman-to-integer/",
            tags: ["哈希表", "数学", "字符串"],
            summary: "遍历罗马数字字符串 <code>s</code>。使用哈希表存储罗马字符对应的值。对当前字符 <code>s[i]</code>，检查其后的字符 <code>s[i+1]</code>。若 <code>value(s[i]) < value(s[i+1])</code>（如 <code>IV</code>），则从结果中减去 <code>value(s[i])</code>；否则，加上 <code>value(s[i])</code>。",
            code: `import java.util.HashMap;
import java.util.Map;

class Solution {
    /**
     * Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
     * ... (rules omitted)...
     * Given a roman numeral, convert it to an integer.
     *
     * @param s Roman numeral string (1 <= s.length <= 15, guaranteed to be valid)
     * @return The corresponding integer
     */
    public int romanToInt(String s) {
        Map<Character, Integer> romanMap = new HashMap<>();
        romanMap.put('I', 1);
        romanMap.put('V', 5);
        romanMap.put('X', 10);
        romanMap.put('L', 50);
        romanMap.put('C', 100);
        romanMap.put('D', 500);
        romanMap.put('M', 1000);

        int result = 0;
        int n = s.length();

        for (int i = 0; i < n; i++) {
            int currentValue = romanMap.get(s.charAt(i));

            // Check if the next character forms a special subtraction case
            if (i < n - 1 && currentValue < romanMap.get(s.charAt(i + 1))) {
                result -= currentValue; // Subtract the current value
            } else {
                result += currentValue; // Add the current value
            }
        }
        return result;
    }
}`
        },
        {
            id: 14,
            title: "最长公共前缀",
            url: "https://leetcode.cn/problems/longest-common-prefix/",
            tags: ["字符串"],
            summary: "方法：<strong>纵向扫描</strong>。以第一个字符串 <code>strs[0]</code> 为基准。遍历其每个字符索引 <code>i</code>。对每个 <code>i</code>，检查所有其他字符串 <code>strs[j]</code> 在索引 <code>i</code> 处的字符是否与 <code>strs[0][i]</code> 相同。若遇到不匹配或某个字符串长度不足 <code>i</code>，则返回 <code>strs[0].substring(0, i)</code>。若遍历完 <code>strs[0]</code> 都匹配，则 <code>strs[0]</code> 即为答案。",
            code: `class Solution {
    /**
     * Write a function to find the longest common prefix string amongst an array of strings.
     * If there is no common prefix, return an empty string "".
     *
     * @param strs Array of strings
     * @return The longest common prefix
     */
    public String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0) {
            return "";
        }

        // Use the first string as the reference
        String firstString = strs[0];
        int prefixLength = firstString.length();
        int count = strs.length;

        // Iterate through characters of the first string
        for (int i = 0; i < prefixLength; i++) {
            char c = firstString.charAt(i); // Character to compare

            // Compare this character with the character at the same position in other strings
            for (int j = 1; j < count; j++) {
                // If the other string is shorter than index i, or characters don't match
                if (i == strs[j].length() || strs[j].charAt(i) != c) {
                    // The common prefix ends before index i
                    return firstString.substring(0, i);
                }
            }
        }

        // If the loop completes, the entire first string is the common prefix
        return firstString;
    }
}`
        },
        {
            id: 15,
            title: "三数之和",
            url: "https://leetcode.cn/problems/3sum/",
            tags: ["数组", "双指针", "排序"],
            summary: "先对数组 <code>nums</code> <strong>排序</strong>。遍历数组，固定第一个数 <code>nums[i]</code>。若 <code>nums[i] > 0</code>，后续不可能和为 0，可提前结束。跳过重复的 <code>nums[i]</code>。然后使用<strong>双指针</strong> <code>left = i + 1</code> 和 <code>right = n - 1</code> 在 <code>i</code> 之后查找。令 <code>target = -nums[i]</code>。当 <code>left < right</code> 时：若 <code>nums[left] + nums[right] == target</code>，记录结果，并移动 <code>left</code> 和 <code>right</code> 跳过重复元素；若和小于 <code>target</code>，<code>left++</code>；若和大于 <code>target</code>，<code>right--</code>。",
            code: `import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Solution {
    /**
     * Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
     * Notice that the solution set must not contain duplicate triplets.
     *
     * @param nums Integer array
     * @return A list of all unique triplets that sum to zero
     */
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        if (nums == null || nums.length < 3) {
            return result;
        }

        // 1. Sort the array
        Arrays.sort(nums);
        int n = nums.length;

        // 2. Iterate through the array, fixing the first element nums[i]
        for (int i = 0; i < n - 2; i++) {
            // Optimization: If the current number is positive, the sum cannot be zero
            if (nums[i] > 0) {
                break;
            }
            // Skip duplicate first elements
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }

            // 3. Use two pointers for the remaining part
            int left = i + 1;
            int right = n - 1;
            int target = -nums[i]; // The target sum for the two pointers

            while (left < right) {
                int sum = nums[left] + nums[right];

                if (sum == target) {
                    // Found a triplet
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));

                    // Skip duplicate second and third elements
                    while (left < right && nums[left] == nums[left + 1]) {
                        left++;
                    }
                    while (left < right && nums[right] == nums[right - 1]) {
                        right--;
                    }

                    // Move pointers to the next distinct elements
                    left++;
                    right--;
                } else if (sum < target) {
                    // Sum is too small, move left pointer
                    left++;
                } else {
                    // Sum is too large, move right pointer
                    right--;
                }
            }
        }
        return result;
    }
}`
        },
        {
            id: 17,
            title: "电话号码的字母组合",
            url: "https://leetcode.cn/problems/letter-combinations-of-a-phone-number/",
            tags: ["哈希表", "字符串", "回溯"],
            summary: "使用<strong>回溯</strong>算法。维护数字到字母的映射 <code>phoneMap</code>。定义递归函数 <code>backtrack(index, currentCombination)</code>。递归基：当 <code>index</code> 等于 <code>digits</code> 长度时，将 <code>currentCombination</code> 加入结果。递归步骤：获取当前数字 <code>digits[index]</code> 对应的字母串 <code>letters</code>。遍历 <code>letters</code> 中每个字母 <code>letter</code>，追加到 <code>currentCombination</code>，递归调用 <code>backtrack(index + 1, ...)</code>，然后从 <code>currentCombination</code> 中删除该字母（回溯）。",
            code: `import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

class Solution {
    // Mapping from digit to letters
    private Map<Character, String> phoneMap = new HashMap<>() {{
        put('2', "abc");
        put('3', "def");
        put('4', "ghi");
        put('5', "jkl");
        put('6', "mno");
        put('7', "pqrs");
        put('8', "tuv");
        put('9', "wxyz");
    }};

    private List<String> combinations = new ArrayList<>(); // Stores the final combinations
    private StringBuilder currentCombination = new StringBuilder(); // Stores the combination being built

    /**
     * Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.
     * Return the answer in any order.
     *
     * @param digits Input string of digits
     * @return List of all possible letter combinations
     */
    public List<String> letterCombinations(String digits) {
        if (digits == null || digits.length() == 0) {
            return combinations;
        }
        backtrack(digits, 0);
        return combinations;
    }

    /**
     * Backtracking function to generate combinations.
     * @param digits The input digit string
     * @param index The current index in the digits string being processed
     */
    private void backtrack(String digits, int index) {
        // Base case: If the current combination length equals the digits length, add it to the result
        if (index == digits.length()) {
            combinations.add(currentCombination.toString());
            return;
        }

        char digit = digits.charAt(index);
        String letters = phoneMap.get(digit);

        // Iterate through the letters corresponding to the current digit
        for (char letter : letters.toCharArray()) {
            // Make a choice: append the current letter
            currentCombination.append(letter);
            // Recurse for the next digit
            backtrack(digits, index + 1);
            // Undo the choice (backtrack): remove the last appended letter
            currentCombination.deleteCharAt(currentCombination.length() - 1);
        }
    }
}`
        },
        {
            id: 19,
            title: "删除链表的倒数第 N 个结点",
            url: "https://leetcode.cn/problems/remove-nth-node-from-end-of-list/",
            tags: ["链表", "双指针"],
            summary: "使用<strong>快慢指针</strong>。创建哑节点 <code>dummy</code> 指向 <code>head</code>。快指针 <code>fast</code> 先向前移动 <code>n</code> 步。然后，慢指针 <code>slow</code> 从 <code>dummy</code> 开始，与 <code>fast</code> 同时向前移动。当 <code>fast</code> 到达链表末尾 (<code>null</code>) 时，<code>slow</code> 正好指向待删除节点的前一个节点。执行删除操作 <code>slow.next = slow.next.next</code>。返回 <code>dummy.next</code>。",
            code: `/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    /**
     * Given the head of a linked list, remove the nth node from the end of the list and return its head.
     *
     * @param head The head of the linked list
     * @param n    The position from the end of the node to remove
     * @return The head of the modified linked list
     */
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // Create a dummy node to handle edge cases like removing the head
        ListNode dummy = new ListNode(0, head);
        ListNode fast = head;
        ListNode slow = dummy; // slow starts at dummy, pointing before the node to potentially remove

        // Move fast pointer n steps ahead
        for (int i = 0; i < n; i++) {
            if (fast != null) {
                fast = fast.next;
            } else {
                // This case should not happen based on constraints (n <= list size),
                // but good practice to handle.
                return head; // Or throw an exception
            }
        }

        // Move both pointers simultaneously until fast reaches the end
        while (fast != null) {
            fast = fast.next;
            slow = slow.next;
        }

        // slow now points to the node *before* the one to be removed
        // Remove the nth node from the end
        if (slow.next != null) {
            slow.next = slow.next.next;
        }

        // Return the head of the modified list (dummy.next)
        return dummy.next;
    }
}`
        },
        {
            id: 20,
            title: "有效的括号",
            url: "https://leetcode.cn/problems/valid-parentheses/",
            tags: ["栈", "字符串"],
            summary: "使用<strong>栈</strong> (<code>Stack</code>) 和哈希映射 (<code>Map</code>) 存储括号配对关系。遍历字符串 <code>s</code>：遇到左括号 (<code>(</code>, <code>[</code>, <code>{</code>)，将其压入栈。遇到右括号 (<code>)</code>, <code>]</code>, <code>}</code>)，检查栈是否为空，或者栈顶元素是否是当前右括号对应的左括号。若栈为空或不匹配，则字符串无效，返回 <code>false</code>。若匹配，则弹出栈顶元素。遍历结束后，检查栈是否为空。若为空，则字符串有效，返回 <code>true</code>；否则无效，返回 <code>false</code>。",
            code: `import java.util.Stack;
import java.util.Map;
import java.util.HashMap;

class Solution {
    /**
     * Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
     * An input string is valid if:
     * 1. Open brackets must be closed by the same type of brackets.
     * 2. Open brackets must be closed in the correct order.
     * 3. Every close bracket has a corresponding open bracket of the same type.
     *
     * @param s Input string containing brackets
     * @return True if the string is valid, false otherwise
     */
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        // Map to store the matching pairs of brackets
        Map<Character, Character> mapping = new HashMap<>();
        mapping.put(')', '(');
        mapping.put(']', '[');
        mapping.put('}', '{');

        for (char c : s.toCharArray()) {
            // If it's an opening bracket, push onto the stack
            if (mapping.containsValue(c)) { // Check if it's one of '(', '[', '{'
                stack.push(c);
            }
            // If it's a closing bracket
            else if (mapping.containsKey(c)) { // Check if it's one of ')', ']', '}'
                // Check if the stack is empty or the top element doesn't match
                if (stack.isEmpty() || stack.peek() != mapping.get(c)) {
                    return false; // Invalid sequence
                }
                // Matching bracket found, pop from stack
                stack.pop();
            }
            // Ignore other characters if any (though problem says only brackets)
        }

        // After iterating through the string, the stack should be empty for a valid string
        return stack.isEmpty();
    }
}`
        },
        {
            id: 21,
            title: "合并两个有序链表",
            url: "https://leetcode.cn/problems/merge-two-sorted-lists/",
            tags: ["递归", "链表"],
            summary: "方法1：<strong>迭代</strong>。创建哑节点 <code>dummy</code> 和当前指针 <code>current</code>。比较 <code>list1</code> 和 <code>list2</code> 的当前节点值。将值较小的节点连接到 <code>current.next</code>，并移动该链表的指针和 <code>current</code> 指针。当一个链表为空时，将另一个链表的剩余部分连接到 <code>current.next</code>。返回 <code>dummy.next</code>。\n方法2：<strong>递归</strong>。比较 <code>list1</code> 和 <code>list2</code> 的头节点。值较小的节点作为新头节点，其 <code>next</code> 指向对其余部分递归调用的结果。",
            code: `/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    /**
     * Merge two sorted linked lists and return it as a new sorted list.
     * The new list should be made by splicing together the nodes of the first two lists.
     *
     * @param list1 Head of the first sorted linked list
     * @param list2 Head of the second sorted linked list
     * @return Head of the merged sorted linked list
     */
    // Iterative Approach
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        // Create a dummy node to simplify the merging process
        ListNode dummy = new ListNode(-1);
        ListNode current = dummy; // Pointer to the current node in the merged list

        // Pointers to traverse list1 and list2
        ListNode p1 = list1;
        ListNode p2 = list2;

        // Iterate while both lists have nodes
        while (p1 != null && p2 != null) {
            if (p1.val <= p2.val) {
                current.next = p1; // Append the smaller node from list1
                p1 = p1.next;      // Move p1 forward
            } else {
                current.next = p2; // Append the smaller node from list2
                p2 = p2.next;      // Move p2 forward
            }
            current = current.next; // Move the current pointer forward in the merged list
        }

        // Append the remaining nodes from either list1 or list2
        if (p1 != null) {
            current.next = p1;
        } else {
            current.next = p2;
        }

        // Return the head of the merged list (dummy.next)
        return dummy.next;
    }
}`
        },
        {
            id: 22,
            title: "括号生成",
            url: "https://leetcode.cn/problems/generate-parentheses/",
            tags: ["字符串", "动态规划", "回溯"],
            summary: "使用<strong>回溯</strong>算法生成所有有效的括号组合。定义递归函数 <code>backtrack(currentString, openCount, closeCount, n)</code>。参数：<code>currentString</code> 当前构建的字符串，<code>openCount</code> 已用左括号数，<code>closeCount</code> 已用右括号数，<code>n</code> 目标括号对数。递归基：当 <code>currentString</code> 长度达到 <code>2*n</code> 时，将其加入结果列表。递归步骤：如果 <code>openCount < n</code>，可以添加左括号，递归调用 <code>backtrack(..., openCount + 1, ...)</code>，然后回溯。如果 <code>closeCount < openCount</code>，可以添加右括号，递归调用 <code>backtrack(..., closeCount + 1, ...)</code>，然后回溯。",
            code: `import java.util.ArrayList;
import java.util.List;

class Solution {
    private List<String> result = new ArrayList<>(); // Stores the final valid combinations

    /**
     * Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
     *
     * @param n The number of pairs of parentheses
     * @return A list of all valid parenthesis combinations
     */
    public List<String> generateParenthesis(int n) {
        backtrack(new StringBuilder(), 0, 0, n);
        return result;
    }

    /**
     * Backtracking function to generate parentheses.
     * @param current The StringBuilder holding the current combination being built
     * @param open    The count of open parentheses used so far
     * @param close   The count of close parentheses used so far
     * @param max     The target number of pairs (n)
     */
    private void backtrack(StringBuilder current, int open, int close, int max) {
        // Base case: If the length of the current string is 2 * max, we have a complete combination
        if (current.length() == max * 2) {
            result.add(current.toString());
            return;
        }

        // Condition to add an open parenthesis: if the count of open parentheses is less than max
        if (open < max) {
            current.append('('); // Make the choice
            backtrack(current, open + 1, close, max); // Recurse
            current.deleteCharAt(current.length() - 1); // Undo the choice (backtrack)
        }

        // Condition to add a close parenthesis: if the count of close parentheses is less than the count of open parentheses
        if (close < open) {
            current.append(')'); // Make the choice
            backtrack(current, open, close + 1, max); // Recurse
            current.deleteCharAt(current.length() - 1); // Undo the choice (backtrack)
        }
    }
}`
        },
        {
            id: 23,
            title: "合并K个升序链表",
            url: "https://leetcode.cn/problems/merge-k-sorted-lists/",
            tags: ["链表", "分治", "堆（优先队列）", "归并排序"],
            summary: "方法1：<strong>优先队列（最小堆）</strong>。将 <code>k</code> 个链表的头节点放入最小堆 (<code>PriorityQueue<ListNode></code>，按节点值排序)。循环：从堆中取出最小节点，加入结果链表，并将该节点的下一个节点（若存在）加入堆。时间 O(N log k)，空间 O(k)。\n方法2：<strong>分治（归并排序）</strong>。将 <code>k</code> 个链表两两合并，得到 <code>k/2</code> 个链表，再两两合并... 直到合并为一个链表。时间 O(N log k)，空间 O(log k)（递归栈）。",
            code: `import java.util.PriorityQueue;
import java.util.Comparator;
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    /**
     * Merge k sorted linked lists and return it as one sorted list.
     * Analyze and describe its complexity.
     *
     * @param lists Array of sorted linked lists
     * @return Head of the merged sorted linked list
     */
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists == null || lists.length == 0) {
            return null;
        }

        // Create a min-heap (PriorityQueue) based on node values
        PriorityQueue<ListNode> minHeap = new PriorityQueue<>(Comparator.comparingInt(node -> node.val));

        // Add the head node of each non-empty list to the min-heap
        for (ListNode head : lists) {
            if (head != null) {
                minHeap.add(head);
            }
        }

        ListNode dummy = new ListNode(-1); // Dummy head for the result list
        ListNode current = dummy; // Pointer to the current node in the result list

        // Continuously extract the minimum node from the heap and add to the result list
        while (!minHeap.isEmpty()) {
            ListNode smallest = minHeap.poll(); // Get the node with the smallest value
            current.next = smallest;           // Append it to the result list
            current = current.next;           // Move the current pointer

            // If the extracted node has a next node, add it to the heap
            if (smallest.next != null) {
                minHeap.add(smallest.next);
            }
        }

        return dummy.next; // Return the head of the merged list
    }
}
// ListNode class definition assumed to be available
// class ListNode { int val; ListNode next; ... }`
        }

    ]

    // --- Add Hot 100 tag dynamically ---
    problemsData.forEach(problem => {
        if (hot100Titles.has(problem.title)) {
            if (!problem.tags.includes("Hot 100")) { // Avoid duplicates if already present
                problem.tags.push("Hot 100");
            }
        } else {
            // Ensure "Hot 100" is removed if the title is not in the list
            const index = problem.tags.indexOf("Hot 100");
            if (index > -1) {
                problem.tags.splice(index, 1);
            }
        }
    });


    // --- DOM Elements ---
    const tableBody = document.getElementById('problemsTable').querySelector('tbody');
    const searchInput = document.getElementById('searchInput');
    const tagFilterContainer = document.getElementById('tagFilterContainer');
    const clearTagFilterButton = document.getElementById('clearTagFilter');
    const noResultsRow = document.getElementById('noResultsRow');
    const sortHeader = document.getElementById('sortHeader');
    const sortIcon = document.getElementById('sortIcon');

    // --- State Variables ---
    let currentSort = 'asc'; // Initial sort order ('asc' or 'desc')
    let currentSearchTerm = '';
    // Use a Set to store multiple selected tags
    let selectedTags = new Set(); // Changed from currentSelectedTag

    // --- Functions ---

    /**
     * Sets up the tag filter buttons based on available tags in the data.
     */
    function setupTagFilters() {
        tagFilterContainer.innerHTML = ''; // Clear existing buttons except the template
        tagFilterContainer.appendChild(clearTagFilterButton); // Re-add clear button

        const tags = new Set();
        problemsData.forEach(p => p.tags.forEach(tag => tags.add(tag)));
        // Sort tags, potentially placing "Hot 100" first or last if desired
        const sortedTags = Array.from(tags).sort((a, b) => {
            if (a === 'Hot 100') return -1; // Put Hot 100 first
            if (b === 'Hot 100') return 1;
            return a.localeCompare(b); // Sort others alphabetically
        });


        sortedTags.forEach(tag => {
            const button = document.createElement('button');
            button.textContent = tag;
            button.dataset.tag = tag; // Store tag in data attribute
            // Determine base color class based on tag type
            const baseColorClass = tag === 'Hot 100' ? 'tag-hot100 bg-blue-100 text-blue-800' : 'tag-default bg-green-100 text-green-800';
            button.classList.add(
                'tag-filter-button', 'px-3', 'py-1', // Base classes
                'text-xs', 'font-medium', 'rounded-full',
                'hover:opacity-80', // Hover effect
                ...baseColorClass.split(' ') // Apply base color
            );

            // Add click listener to toggle tag selection
            button.addEventListener('click', () => toggleTagFilter(tag, button));
            // Insert before the "Clear Filter" button
            tagFilterContainer.insertBefore(button, clearTagFilterButton);
        });

        // Add click listener for the clear button
        clearTagFilterButton.addEventListener('click', clearAllTagFilters);
    }

    /**
     * Toggles the selection state of a tag filter button.
     * @param {string} tag - The tag associated with the button.
     * @param {HTMLElement} buttonElement - The button element that was clicked.
     */
    function toggleTagFilter(tag, buttonElement) {
        if (selectedTags.has(tag)) {
            // Tag is currently selected, deselect it
            selectedTags.delete(tag);
            buttonElement.classList.remove('active');
            // Reset background based on tag type
            if (tag === 'Hot 100') {
                buttonElement.classList.add('bg-blue-100', 'text-blue-800');
                buttonElement.classList.remove('bg-blue-600', 'text-white');
            } else {
                buttonElement.classList.add('bg-green-100', 'text-green-800');
                buttonElement.classList.remove('bg-green-600', 'text-white');
            }
        } else {
            // Tag is not selected, select it
            selectedTags.add(tag);
            buttonElement.classList.add('active');
            // Set active background based on tag type
            if (tag === 'Hot 100') {
                buttonElement.classList.remove('bg-blue-100', 'text-blue-800');
                buttonElement.classList.add('bg-blue-600', 'text-white');
            } else {
                buttonElement.classList.remove('bg-green-100', 'text-green-800');
                buttonElement.classList.add('bg-green-600', 'text-white');
            }
        }

        // Show/hide clear button based on whether any tags are selected
        clearTagFilterButton.classList.toggle('hidden', selectedTags.size === 0);

        renderTable(); // Re-render the table with updated filters
    }

    /**
     * Clears all selected tag filters.
     */
    function clearAllTagFilters() {
        selectedTags.clear(); // Clear the set of selected tags
        // Deactivate all tag buttons
        const allTagButtons = tagFilterContainer.querySelectorAll('.tag-filter-button');
        allTagButtons.forEach(button => {
            button.classList.remove('active');
            const tag = button.dataset.tag;
            // Reset background based on tag type
            if (tag === 'Hot 100') {
                button.classList.add('bg-blue-100', 'text-blue-800');
                button.classList.remove('bg-blue-600', 'text-white');
            } else {
                button.classList.add('bg-green-100', 'text-green-800');
                button.classList.remove('bg-green-600', 'text-white');
            }
        });
        clearTagFilterButton.classList.add('hidden'); // Hide the clear button
        renderTable(); // Re-render the table
    }


    /**
     * Updates the sort icon (▲/▼) in the table header based on the current sort direction.
     */
    function updateSortIcon() {
        if (currentSort === 'asc') {
            sortIcon.textContent = '▲'; // Up arrow for ascending
        } else {
            sortIcon.textContent = '▼'; // Down arrow for descending
        }
        sortIcon.classList.remove('text-gray-400');
        sortIcon.classList.add('text-indigo-600'); // Highlight active sort icon
    }

    /**
     * Adds copy functionality to all code blocks.
     */
    function addCopyButtons() {
        const codeBlocks = tableBody.querySelectorAll('pre[class*="language-"]');
        codeBlocks.forEach(block => {
            // Prevent adding multiple buttons if re-rendered
            if (block.querySelector('.copy-button')) {
                return;
            }

            const button = document.createElement('button');
            button.textContent = '复制';
            button.classList.add('copy-button');

            button.addEventListener('click', () => {
                const code = block.querySelector('code').innerText;
                navigator.clipboard.writeText(code).then(() => {
                    button.textContent = '已复制!';
                    button.classList.add('copied');
                    setTimeout(() => {
                        button.textContent = '复制';
                        button.classList.remove('copied');
                    }, 2000); // Reset after 2 seconds
                }).catch(err => {
                    console.error('Failed to copy code: ', err);
                    button.textContent = '失败';
                    setTimeout(() => {
                        button.textContent = '复制';
                    }, 2000);
                });
            });

            block.appendChild(button);
        });
    }


    /**
     * Renders the table content based on current filters and sort order.
     */
    function renderTable() {
        // Clear previous table content, keeping the 'no results' row template
        tableBody.innerHTML = '';
        tableBody.appendChild(noResultsRow); // Keep the template row

        // 1. Filter by Search Term
        let filteredData = problemsData.filter(p => {
            const searchTerm = currentSearchTerm.toLowerCase().trim();
            if (!searchTerm) return true; // No search term, include all
            // Check if ID or title includes the search term
            return String(p.id).includes(searchTerm) || p.title.toLowerCase().includes(searchTerm);
        });

        // 2. Filter by Selected Tags (Multiple)
        if (selectedTags.size > 0) {
            filteredData = filteredData.filter(p => {
                // Check if the problem's tags contain ALL selected tags
                for (const selectedTag of selectedTags) {
                    if (!p.tags.includes(selectedTag)) {
                        return false; // Problem doesn't have one of the selected tags
                    }
                }
                return true; // Problem has all selected tags
            });
        }

        // 3. Sort based on currentSort state
        filteredData.sort((a, b) => {
            return currentSort === 'asc' ? a.id - b.id : b.id - a.id;
        });

        // 4. Render Rows or show 'no results' message
        if (filteredData.length === 0) {
            noResultsRow.classList.remove('hidden'); // Show 'no results' row
        } else {
            noResultsRow.classList.add('hidden'); // Hide 'no results' row
            filteredData.forEach(problem => {
                const row = tableBody.insertRow();
                row.classList.add('hover:bg-gray-50'); // Add hover effect

                // Generate tag spans with specific colors
                const tagSpans = problem.tags.map(tag => {
                    const tagClass = tag === 'Hot 100' ? 'tag-hot100 bg-blue-100 text-blue-800' : 'tag-default bg-green-100 text-green-800';
                    return `<span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${tagClass}">${tag}</span>`;
                }).join(' ');


                // Populate row cells with problem data
                // Use template literals (backticks) for easier HTML embedding
                row.innerHTML = `
          <td class="px-4 py-3 align-top whitespace-nowrap text-sm font-medium text-gray-900">${problem.id}</td>
          <td class="px-4 py-3 align-top text-sm text-gray-700">
            <a href="${problem.url}" target="_blank" class="text-indigo-600 hover:text-indigo-800 hover:underline">${problem.title}</a>
          </td>
          <td class="px-4 py-3 align-top text-sm text-gray-500">
            <div class="flex flex-wrap gap-1">
              ${tagSpans}
            </div>
          </td>
          <td class="px-4 py-3 align-top text-sm text-gray-600 solution-summary-col" style="word-wrap: break-word; white-space: normal;">${problem.summary.replace(/\n/g, '<br>')}</td>
          <td class="px-4 py-3 align-top text-sm text-gray-900 code-col">
            <details>
              <summary>显示/隐藏代码</summary>
              <pre class="language-java rounded-md"><code>${escapeHtml(problem.code)}</code></pre>
            </details>
          </td>
        `;
                // Ensure all cells are vertically aligned to the top
                Array.from(row.cells).forEach(cell => cell.classList.add('align-top'));
            });
        }
        // Apply syntax highlighting to the newly added code blocks
        Prism.highlightAllUnder(tableBody);
        // Add copy buttons to the new code blocks
        addCopyButtons();
    }

    /**
     * Escapes HTML special characters to prevent XSS and rendering issues.
     * @param {string} unsafe - The potentially unsafe string.
     * @returns {string} - The escaped string.
     */
    function escapeHtml(unsafe) {
        // Ensure input is a string before attempting to replace
        if (typeof unsafe !== 'string') {
            console.warn("escapeHtml called with non-string value:", unsafe);
            return ''; // Return empty string or handle appropriately based on context
        }
        return unsafe
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }

    // --- Event Listeners ---

    // Listen for input in the search box
    searchInput.addEventListener('input', (e) => {
        currentSearchTerm = e.target.value; // Update search term state
        renderTable(); // Re-render table
    });

    // Listen for clicks on the sortable table header
    sortHeader.addEventListener('click', () => {
        // Toggle sort direction
        currentSort = (currentSort === 'asc') ? 'desc' : 'asc';
        updateSortIcon(); // Update the arrow icon
        renderTable(); // Re-render table with new sort order
    });


    // --- Initial Setup ---
    // Run when the DOM is fully loaded
    document.addEventListener('DOMContentLoaded', () => {
        // Add Hot 100 tags dynamically before setting up filters and rendering
        problemsData.forEach(problem => {
            if (hot100Titles.has(problem.title)) {
                if (!problem.tags.includes("Hot 100")) {
                    problem.tags.push("Hot 100");
                }
            } else {
                const index = problem.tags.indexOf("Hot 100");
                if (index > -1) {
                    problem.tags.splice(index, 1);
                }
            }
        });

        setupTagFilters(); // Create tag filter buttons based on updated data
        updateSortIcon(); // Set the initial sort icon
        renderTable(); // Perform the initial render of the table
    });

</script>

</body>
</html>
